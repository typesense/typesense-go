// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"encoding/json"

	"github.com/oapi-codegen/runtime"
)

const (
	Api_key_headerScopes = "api_key_header.Scopes"
)

// Defines values for AnalyticsRuleSchemaType.
const (
	AnalyticsRuleSchemaTypeCounter        AnalyticsRuleSchemaType = "counter"
	AnalyticsRuleSchemaTypeNohitsQueries  AnalyticsRuleSchemaType = "nohits_queries"
	AnalyticsRuleSchemaTypePopularQueries AnalyticsRuleSchemaType = "popular_queries"
)

// Defines values for AnalyticsRuleUpsertSchemaType.
const (
	AnalyticsRuleUpsertSchemaTypeCounter        AnalyticsRuleUpsertSchemaType = "counter"
	AnalyticsRuleUpsertSchemaTypeNohitsQueries  AnalyticsRuleUpsertSchemaType = "nohits_queries"
	AnalyticsRuleUpsertSchemaTypePopularQueries AnalyticsRuleUpsertSchemaType = "popular_queries"
)

// Defines values for DirtyValues.
const (
	CoerceOrDrop   DirtyValues = "coerce_or_drop"
	CoerceOrReject DirtyValues = "coerce_or_reject"
	Drop           DirtyValues = "drop"
	Reject         DirtyValues = "reject"
)

// Defines values for DropTokensMode.
const (
	BothSides3  DropTokensMode = "both_sides:3"
	LeftToRight DropTokensMode = "left_to_right"
	RightToLeft DropTokensMode = "right_to_left"
)

// Defines values for IndexAction.
const (
	Create  IndexAction = "create"
	Emplace IndexAction = "emplace"
	Update  IndexAction = "update"
	Upsert  IndexAction = "upsert"
)

// Defines values for SearchOverrideRuleMatch.
const (
	Contains SearchOverrideRuleMatch = "contains"
	Exact    SearchOverrideRuleMatch = "exact"
)

// APIStatsResponse defines model for APIStatsResponse.
type APIStatsResponse struct {
	DeleteLatencyMs             *float64            `json:"delete_latency_ms,omitempty"`
	DeleteRequestsPerSecond     *float64            `json:"delete_requests_per_second,omitempty"`
	ImportLatencyMs             *float64            `json:"import_latency_ms,omitempty"`
	ImportRequestsPerSecond     *float64            `json:"import_requests_per_second,omitempty"`
	LatencyMs                   *map[string]float64 `json:"latency_ms,omitempty"`
	OverloadedRequestsPerSecond *float64            `json:"overloaded_requests_per_second,omitempty"`
	PendingWriteBatches         *float64            `json:"pending_write_batches,omitempty"`
	RequestsPerSecond           *map[string]float64 `json:"requests_per_second,omitempty"`
	SearchLatencyMs             *float64            `json:"search_latency_ms,omitempty"`
	SearchRequestsPerSecond     *float64            `json:"search_requests_per_second,omitempty"`
	TotalRequestsPerSecond      *float64            `json:"total_requests_per_second,omitempty"`
	WriteLatencyMs              *float64            `json:"write_latency_ms,omitempty"`
	WriteRequestsPerSecond      *float64            `json:"write_requests_per_second,omitempty"`
}

// AnalyticsEventCreateResponse defines model for AnalyticsEventCreateResponse.
type AnalyticsEventCreateResponse struct {
	Ok bool `json:"ok"`
}

// AnalyticsEventCreateSchema defines model for AnalyticsEventCreateSchema.
type AnalyticsEventCreateSchema struct {
	Data map[string]interface{} `json:"data"`
	Name string                 `json:"name"`
	Type string                 `json:"type"`
}

// AnalyticsRuleDeleteResponse defines model for AnalyticsRuleDeleteResponse.
type AnalyticsRuleDeleteResponse struct {
	Name string `json:"name"`
}

// AnalyticsRuleParameters defines model for AnalyticsRuleParameters.
type AnalyticsRuleParameters struct {
	Destination AnalyticsRuleParametersDestination `json:"destination"`
	ExpandQuery *bool                              `json:"expand_query,omitempty"`
	Limit       *int                               `json:"limit,omitempty"`
	Source      AnalyticsRuleParametersSource      `json:"source"`
}

// AnalyticsRuleParametersDestination defines model for AnalyticsRuleParametersDestination.
type AnalyticsRuleParametersDestination struct {
	Collection   string  `json:"collection"`
	CounterField *string `json:"counter_field,omitempty"`
}

// AnalyticsRuleParametersSource defines model for AnalyticsRuleParametersSource.
type AnalyticsRuleParametersSource struct {
	Collections []string `json:"collections"`
	Events      *[]struct {
		Name   string  `json:"name"`
		Type   string  `json:"type"`
		Weight float32 `json:"weight"`
	} `json:"events,omitempty"`
}

// AnalyticsRuleSchema defines model for AnalyticsRuleSchema.
type AnalyticsRuleSchema struct {
	Name   string                  `json:"name"`
	Params AnalyticsRuleParameters `json:"params"`
	Type   AnalyticsRuleSchemaType `json:"type"`
}

// AnalyticsRuleSchemaType defines model for AnalyticsRuleSchema.Type.
type AnalyticsRuleSchemaType string

// AnalyticsRuleUpsertSchema defines model for AnalyticsRuleUpsertSchema.
type AnalyticsRuleUpsertSchema struct {
	Params AnalyticsRuleParameters       `json:"params"`
	Type   AnalyticsRuleUpsertSchemaType `json:"type"`
}

// AnalyticsRuleUpsertSchemaType defines model for AnalyticsRuleUpsertSchema.Type.
type AnalyticsRuleUpsertSchemaType string

// AnalyticsRulesRetrieveSchema defines model for AnalyticsRulesRetrieveSchema.
type AnalyticsRulesRetrieveSchema struct {
	Rules *[]*AnalyticsRuleSchema `json:"rules,omitempty"`
}

// ApiKey defines model for ApiKey.
type ApiKey struct {
	Actions     []string `json:"actions"`
	Collections []string `json:"collections"`
	Description string   `json:"description"`
	ExpiresAt   *int64   `json:"expires_at,omitempty"`
	Id          *int64   `json:"id,omitempty"`
	Value       *string  `json:"value,omitempty"`
	ValuePrefix *string  `json:"value_prefix,omitempty"`
}

// ApiKeyDeleteResponse defines model for ApiKeyDeleteResponse.
type ApiKeyDeleteResponse struct {
	// Id The id of the API key that was deleted
	Id int64 `json:"id"`
}

// ApiKeySchema defines model for ApiKeySchema.
type ApiKeySchema struct {
	Actions     []string `json:"actions"`
	Collections []string `json:"collections"`
	Description string   `json:"description"`
	ExpiresAt   *int64   `json:"expires_at,omitempty"`
	Value       *string  `json:"value,omitempty"`
}

// ApiKeysResponse defines model for ApiKeysResponse.
type ApiKeysResponse struct {
	Keys []*ApiKey `json:"keys"`
}

// ApiResponse defines model for ApiResponse.
type ApiResponse struct {
	Message string `json:"message"`
}

// CollectionAlias defines model for CollectionAlias.
type CollectionAlias struct {
	// CollectionName Name of the collection the alias mapped to
	CollectionName string `json:"collection_name"`

	// Name Name of the collection alias
	Name *string `json:"name,omitempty"`
}

// CollectionAliasSchema defines model for CollectionAliasSchema.
type CollectionAliasSchema struct {
	// CollectionName Name of the collection you wish to map the alias to
	CollectionName string `json:"collection_name"`
}

// CollectionAliasesResponse defines model for CollectionAliasesResponse.
type CollectionAliasesResponse struct {
	Aliases []*CollectionAlias `json:"aliases"`
}

// CollectionResponse defines model for CollectionResponse.
type CollectionResponse struct {
	// CreatedAt Timestamp of when the collection was created (Unix epoch in seconds)
	CreatedAt *int64 `json:"created_at,omitempty"`

	// DefaultSortingField The name of an int32 / float field that determines the order in which the search results are ranked when a sort_by clause is not provided during searching. This field must indicate some kind of popularity.
	DefaultSortingField *string `json:"default_sorting_field,omitempty"`

	// EnableNestedFields Enables experimental support at a collection level for nested object or object array fields. This field is only available if the Typesense server is version `0.24.0.rcn34` or later.
	EnableNestedFields *bool `json:"enable_nested_fields,omitempty"`

	// Fields A list of fields for querying, filtering and faceting
	Fields []Field `json:"fields"`

	// Metadata Optional details about the collection, e.g., when it was created, who created it etc.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Name of the collection
	Name string `json:"name"`

	// NumDocuments Number of documents in the collection
	NumDocuments *int64 `json:"num_documents,omitempty"`

	// SymbolsToIndex List of symbols or special characters to be indexed.
	SymbolsToIndex *[]string `json:"symbols_to_index,omitempty"`

	// TokenSeparators List of symbols or special characters to be used for splitting the text into individual words in addition to space and new-line characters.
	TokenSeparators *[]string `json:"token_separators,omitempty"`

	// VoiceQueryModel Configuration for the voice query model
	VoiceQueryModel *VoiceQueryModelCollectionConfig `json:"voice_query_model,omitempty"`
}

// CollectionSchema defines model for CollectionSchema.
type CollectionSchema struct {
	// DefaultSortingField The name of an int32 / float field that determines the order in which the search results are ranked when a sort_by clause is not provided during searching. This field must indicate some kind of popularity.
	DefaultSortingField *string `json:"default_sorting_field,omitempty"`

	// EnableNestedFields Enables experimental support at a collection level for nested object or object array fields. This field is only available if the Typesense server is version `0.24.0.rcn34` or later.
	EnableNestedFields *bool `json:"enable_nested_fields,omitempty"`

	// Fields A list of fields for querying, filtering and faceting
	Fields []Field `json:"fields"`

	// Metadata Optional details about the collection, e.g., when it was created, who created it etc.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// Name Name of the collection
	Name string `json:"name"`

	// SymbolsToIndex List of symbols or special characters to be indexed.
	SymbolsToIndex *[]string `json:"symbols_to_index,omitempty"`

	// TokenSeparators List of symbols or special characters to be used for splitting the text into individual words in addition to space and new-line characters.
	TokenSeparators *[]string `json:"token_separators,omitempty"`

	// VoiceQueryModel Configuration for the voice query model
	VoiceQueryModel *VoiceQueryModelCollectionConfig `json:"voice_query_model,omitempty"`
}

// CollectionUpdateSchema defines model for CollectionUpdateSchema.
type CollectionUpdateSchema struct {
	// Fields A list of fields for querying, filtering and faceting
	Fields []Field `json:"fields"`

	// Metadata Optional details about the collection, e.g., when it was created, who created it etc.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`
}

// ConversationModelCreateSchema defines model for ConversationModelCreateSchema.
type ConversationModelCreateSchema struct {
	// AccountId LLM service's account ID (only applicable for Cloudflare)
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey The LLM service's API Key
	ApiKey *string `json:"api_key,omitempty"`

	// HistoryCollection Typesense collection that stores the historical conversations
	HistoryCollection string `json:"history_collection"`

	// Id An explicit id for the model, otherwise the API will return a response with an auto-generated conversation model id.
	Id *string `json:"id,omitempty"`

	// MaxBytes The maximum number of bytes to send to the LLM in every API call. Consult the LLM's documentation on the number of bytes supported in the context window.
	MaxBytes int `json:"max_bytes"`

	// ModelName Name of the LLM model offered by OpenAI, Cloudflare or vLLM
	ModelName string `json:"model_name"`

	// SystemPrompt The system prompt that contains special instructions to the LLM
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Ttl Time interval in seconds after which the messages would be deleted. Default: 86400 (24 hours)
	Ttl *int `json:"ttl,omitempty"`

	// VllmUrl URL of vLLM service
	VllmUrl *string `json:"vllm_url,omitempty"`
}

// ConversationModelSchema defines model for ConversationModelSchema.
type ConversationModelSchema struct {
	// AccountId LLM service's account ID (only applicable for Cloudflare)
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey The LLM service's API Key
	ApiKey *string `json:"api_key,omitempty"`

	// HistoryCollection Typesense collection that stores the historical conversations
	HistoryCollection string `json:"history_collection"`

	// Id An explicit id for the model, otherwise the API will return a response with an auto-generated conversation model id.
	Id string `json:"id"`

	// MaxBytes The maximum number of bytes to send to the LLM in every API call. Consult the LLM's documentation on the number of bytes supported in the context window.
	MaxBytes int `json:"max_bytes"`

	// ModelName Name of the LLM model offered by OpenAI, Cloudflare or vLLM
	ModelName string `json:"model_name"`

	// SystemPrompt The system prompt that contains special instructions to the LLM
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Ttl Time interval in seconds after which the messages would be deleted. Default: 86400 (24 hours)
	Ttl *int `json:"ttl,omitempty"`

	// VllmUrl URL of vLLM service
	VllmUrl *string `json:"vllm_url,omitempty"`
}

// ConversationModelUpdateSchema defines model for ConversationModelUpdateSchema.
type ConversationModelUpdateSchema struct {
	// AccountId LLM service's account ID (only applicable for Cloudflare)
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey The LLM service's API Key
	ApiKey *string `json:"api_key,omitempty"`

	// HistoryCollection Typesense collection that stores the historical conversations
	HistoryCollection *string `json:"history_collection,omitempty"`

	// Id An explicit id for the model, otherwise the API will return a response with an auto-generated conversation model id.
	Id *string `json:"id,omitempty"`

	// MaxBytes The maximum number of bytes to send to the LLM in every API call. Consult the LLM's documentation on the number of bytes supported in the context window.
	MaxBytes *int `json:"max_bytes,omitempty"`

	// ModelName Name of the LLM model offered by OpenAI, Cloudflare or vLLM
	ModelName *string `json:"model_name,omitempty"`

	// SystemPrompt The system prompt that contains special instructions to the LLM
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Ttl Time interval in seconds after which the messages would be deleted. Default: 86400 (24 hours)
	Ttl *int `json:"ttl,omitempty"`

	// VllmUrl URL of vLLM service
	VllmUrl *string `json:"vllm_url,omitempty"`
}

// DirtyValues defines model for DirtyValues.
type DirtyValues string

// DropTokensMode Dictates the direction in which the words in the query must be dropped when the original words in the query do not appear in any document. Values: right_to_left (default), left_to_right, both_sides:3 A note on both_sides:3 - for queries upto 3 tokens (words) in length, this mode will drop tokens from both sides and exhaustively rank all matching results. If query length is greater than 3 words, Typesense will just fallback to default behavior of right_to_left
type DropTokensMode string

// FacetCounts defines model for FacetCounts.
type FacetCounts struct {
	Counts *[]struct {
		Count       *int                    `json:"count,omitempty"`
		Highlighted *string                 `json:"highlighted,omitempty"`
		Parent      *map[string]interface{} `json:"parent,omitempty"`
		Value       *string                 `json:"value,omitempty"`
	} `json:"counts,omitempty"`
	FieldName *string `json:"field_name,omitempty"`
	Stats     *struct {
		Avg         *float64 `json:"avg,omitempty"`
		Max         *float64 `json:"max,omitempty"`
		Min         *float64 `json:"min,omitempty"`
		Sum         *float64 `json:"sum,omitempty"`
		TotalValues *int     `json:"total_values,omitempty"`
	} `json:"stats,omitempty"`
}

// Field defines model for Field.
type Field struct {
	Drop  *bool `json:"drop,omitempty"`
	Embed *struct {
		From        []string `json:"from"`
		ModelConfig struct {
			AccessToken    *string `json:"access_token,omitempty"`
			ApiKey         *string `json:"api_key,omitempty"`
			ClientId       *string `json:"client_id,omitempty"`
			ClientSecret   *string `json:"client_secret,omitempty"`
			IndexingPrefix *string `json:"indexing_prefix,omitempty"`
			ModelName      string  `json:"model_name"`
			ProjectId      *string `json:"project_id,omitempty"`
			QueryPrefix    *string `json:"query_prefix,omitempty"`
			RefreshToken   *string `json:"refresh_token,omitempty"`
			Url            *string `json:"url,omitempty"`
		} `json:"model_config"`
	} `json:"embed,omitempty"`
	Facet    *bool   `json:"facet,omitempty"`
	Index    *bool   `json:"index,omitempty"`
	Infix    *bool   `json:"infix,omitempty"`
	Locale   *string `json:"locale,omitempty"`
	Name     string  `json:"name"`
	NumDim   *int    `json:"num_dim,omitempty"`
	Optional *bool   `json:"optional,omitempty"`

	// RangeIndex Enables an index optimized for range filtering on numerical fields (e.g. rating:>3.5). Default: false.
	RangeIndex *bool `json:"range_index,omitempty"`

	// Reference Name of a field in another collection that should be linked to this collection so that it can be joined during query.
	Reference *string `json:"reference,omitempty"`
	Sort      *bool   `json:"sort,omitempty"`

	// Stem Values are stemmed before indexing in-memory. Default: false.
	Stem *bool `json:"stem,omitempty"`

	// StemDictionary Name of the stemming dictionary to use for this field
	StemDictionary *string `json:"stem_dictionary,omitempty"`

	// Store When set to false, the field value will not be stored on disk. Default: true.
	Store *bool `json:"store,omitempty"`

	// SymbolsToIndex List of symbols or special characters to be indexed.
	SymbolsToIndex *[]string `json:"symbols_to_index,omitempty"`

	// TokenSeparators List of symbols or special characters to be used for splitting the text into individual words in addition to space and new-line characters.
	TokenSeparators *[]string `json:"token_separators,omitempty"`
	Type            string    `json:"type"`

	// VecDist The distance metric to be used for vector search. Default: `cosine`. You can also use `ip` for inner product.
	VecDist *string `json:"vec_dist,omitempty"`
}

// HealthStatus defines model for HealthStatus.
type HealthStatus struct {
	Ok bool `json:"ok"`
}

// IndexAction defines model for IndexAction.
type IndexAction string

// MultiSearchCollectionParameters defines model for MultiSearchCollectionParameters.
type MultiSearchCollectionParameters struct {
	// CacheTtl The duration (in seconds) that determines how long the search query is cached. This value can be set on a per-query basis. Default: 60.
	CacheTtl *int `json:"cache_ttl,omitempty"`

	// Collection The collection to search in.
	Collection *string `json:"collection,omitempty"`

	// Conversation Enable conversational search.
	Conversation *bool `json:"conversation,omitempty"`

	// ConversationId The Id of a previous conversation to continue, this tells Typesense to include prior context when communicating with the LLM.
	ConversationId *string `json:"conversation_id,omitempty"`

	// ConversationModelId The Id of Conversation Model to be used.
	ConversationModelId *string `json:"conversation_model_id,omitempty"`

	// DropTokensMode Dictates the direction in which the words in the query must be dropped when the original words in the query do not appear in any document. Values: right_to_left (default), left_to_right, both_sides:3 A note on both_sides:3 - for queries upto 3 tokens (words) in length, this mode will drop tokens from both sides and exhaustively rank all matching results. If query length is greater than 3 words, Typesense will just fallback to default behavior of right_to_left
	DropTokensMode *DropTokensMode `json:"drop_tokens_mode,omitempty"`

	// DropTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to drop the tokens in the query until enough results are found. Tokens that have the least individual hits are dropped first. Set to 0 to disable. Default: 10
	DropTokensThreshold *int `json:"drop_tokens_threshold,omitempty"`

	// EnableOverrides If you have some overrides defined but want to disable all of them during query time, you can do that by setting this parameter to false
	EnableOverrides *bool `json:"enable_overrides,omitempty"`

	// EnableSynonyms If you have some synonyms defined but want to disable all of them for a particular search query, set enable_synonyms to false. Default: true
	EnableSynonyms *bool `json:"enable_synonyms,omitempty"`

	// EnableTyposForAlphaNumericalTokens Set this parameter to false to disable typos on alphanumerical query tokens. Default: true.
	EnableTyposForAlphaNumericalTokens *bool `json:"enable_typos_for_alpha_numerical_tokens,omitempty"`

	// EnableTyposForNumericalTokens Make Typesense disable typos for numerical tokens.
	EnableTyposForNumericalTokens *bool `json:"enable_typos_for_numerical_tokens,omitempty"`

	// ExcludeFields List of fields from the document to exclude in the search result
	ExcludeFields *string `json:"exclude_fields,omitempty"`

	// ExhaustiveSearch Setting this to true will make Typesense consider all prefixes and typo corrections of the words in the query without stopping early when enough results are found (drop_tokens_threshold and typo_tokens_threshold configurations are ignored).
	ExhaustiveSearch *bool `json:"exhaustive_search,omitempty"`

	// FacetBy A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.
	FacetBy *string `json:"facet_by,omitempty"`

	// FacetQuery Facet values that are returned can now be filtered via this parameter. The matching facet text is also highlighted. For example, when faceting by `category`, you can set `facet_query=category:shoe` to return only facet values that contain the prefix "shoe".
	FacetQuery *string `json:"facet_query,omitempty"`

	// FacetReturnParent Comma separated string of nested facet fields whose parent object should be returned in facet response.
	FacetReturnParent *string `json:"facet_return_parent,omitempty"`

	// FacetStrategy Choose the underlying faceting strategy used. Comma separated string of allows values: exhaustive, top_values or automatic (default).
	FacetStrategy *string `json:"facet_strategy,omitempty"`

	// FilterBy Filter conditions for refining youropen api validator search results. Separate multiple conditions with &&.
	FilterBy *string `json:"filter_by,omitempty"`

	// FilterCuratedHits Whether the filter_by condition of the search query should be applicable to curated results (override definitions, pinned hits, hidden hits, etc.). Default: false
	FilterCuratedHits *bool `json:"filter_curated_hits,omitempty"`

	// GroupBy You can aggregate search results into groups or buckets by specify one or more `group_by` fields. Separate multiple fields with a comma. To group on a particular field, it must be a faceted field.
	GroupBy *string `json:"group_by,omitempty"`

	// GroupLimit Maximum number of hits to be returned for every group. If the `group_limit` is set as `K` then only the top K hits in each group are returned in the response. Default: 3
	GroupLimit *int `json:"group_limit,omitempty"`

	// GroupMissingValues Setting this parameter to true will place all documents that have a null value in the group_by field, into a single group. Setting this parameter to false, will cause each document with a null value in the group_by field to not be grouped with other documents. Default: true
	GroupMissingValues *bool `json:"group_missing_values,omitempty"`

	// HiddenHits A list of records to unconditionally hide from search results. A list of `record_id`s to hide. Eg: to hide records with IDs 123 and 456, you'd specify `123,456`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	HiddenHits *string `json:"hidden_hits,omitempty"`

	// HighlightAffixNumTokens The number of tokens that should surround the highlighted text on each side. Default: 4
	HighlightAffixNumTokens *int `json:"highlight_affix_num_tokens,omitempty"`

	// HighlightEndTag The end tag used for the highlighted snippets. Default: `</mark>`
	HighlightEndTag *string `json:"highlight_end_tag,omitempty"`

	// HighlightFields A list of custom fields that must be highlighted even if you don't query for them
	HighlightFields *string `json:"highlight_fields,omitempty"`

	// HighlightFullFields List of fields which should be highlighted fully without snippeting
	HighlightFullFields *string `json:"highlight_full_fields,omitempty"`

	// HighlightStartTag The start tag used for the highlighted snippets. Default: `<mark>`
	HighlightStartTag *string `json:"highlight_start_tag,omitempty"`

	// IncludeFields List of fields from the document to include in the search result
	IncludeFields *string `json:"include_fields,omitempty"`

	// Infix If infix index is enabled for this field, infix searching can be done on a per-field basis by sending a comma separated string parameter called infix to the search query. This parameter can have 3 values; `off` infix search is disabled, which is default `always` infix search is performed along with regular search `fallback` infix search is performed if regular search does not produce results
	Infix *string `json:"infix,omitempty"`

	// Limit Number of hits to fetch. Can be used as an alternative to the per_page parameter. Default: 10.
	Limit *int `json:"limit,omitempty"`

	// MaxExtraPrefix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraPrefix *int `json:"max_extra_prefix,omitempty"`

	// MaxExtraSuffix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraSuffix *int `json:"max_extra_suffix,omitempty"`

	// MaxFacetValues Maximum number of facet values to be returned.
	MaxFacetValues *int `json:"max_facet_values,omitempty"`

	// MinLen1typo Minimum word length for 1-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen1typo *int `json:"min_len_1typo,omitempty"`

	// MinLen2typo Minimum word length for 2-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen2typo *int `json:"min_len_2typo,omitempty"`

	// NumTypos The number of typographical errors (1 or 2) that would be tolerated. Default: 2
	NumTypos *string `json:"num_typos,omitempty"`

	// Offset Identifies the starting point to return hits from a result set. Can be used as an alternative to the page parameter.
	Offset *int `json:"offset,omitempty"`

	// OverrideTags Comma separated list of tags to trigger the curations rules that match the tags.
	OverrideTags *string `json:"override_tags,omitempty"`

	// Page Results from this specific page number would be fetched.
	Page *int `json:"page,omitempty"`

	// PerPage Number of results to fetch per page. Default: 10
	PerPage *int `json:"per_page,omitempty"`

	// PinnedHits A list of records to unconditionally include in the search results at specific positions. An example use case would be to feature or promote certain items on the top of search results. A list of `record_id:hit_position`. Eg: to include a record with ID 123 at Position 1 and another record with ID 456 at Position 5, you'd specify `123:1,456:5`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	PinnedHits *string `json:"pinned_hits,omitempty"`

	// PreSegmentedQuery You can index content from any logographic language into Typesense if you are able to segment / split the text into space-separated words yourself before indexing and querying.
	// Set this parameter to true to do the same
	PreSegmentedQuery *bool `json:"pre_segmented_query,omitempty"`

	// Prefix Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole word. This is used for building autocomplete and instant search interfaces. Defaults to true.
	Prefix *string `json:"prefix,omitempty"`

	// Preset Search using a bunch of search parameters by setting this parameter to the name of the existing Preset.
	Preset *string `json:"preset,omitempty"`

	// PrioritizeExactMatch Set this parameter to true to ensure that an exact match is ranked above the others
	PrioritizeExactMatch *bool `json:"prioritize_exact_match,omitempty"`

	// PrioritizeNumMatchingFields Make Typesense prioritize documents where the query words appear in more number of fields.
	PrioritizeNumMatchingFields *bool `json:"prioritize_num_matching_fields,omitempty"`

	// PrioritizeTokenPosition Make Typesense prioritize documents where the query words appear earlier in the text.
	PrioritizeTokenPosition *bool `json:"prioritize_token_position,omitempty"`

	// Q The query text to search for in the collection. Use * as the search string to return all documents. This is typically useful when used in conjunction with filter_by.
	Q *string `json:"q,omitempty"`

	// QueryBy A list of `string` fields that should be queried against. Multiple fields are separated with a comma.
	QueryBy *string `json:"query_by,omitempty"`

	// QueryByWeights The relative weight to give each `query_by` field when ranking results. This can be used to boost fields in priority, when looking for matches. Multiple fields are separated with a comma.
	QueryByWeights *string `json:"query_by_weights,omitempty"`

	// RemoteEmbeddingNumTries Number of times to retry fetching remote embeddings.
	RemoteEmbeddingNumTries *int `json:"remote_embedding_num_tries,omitempty"`

	// RemoteEmbeddingTimeoutMs Timeout (in milliseconds) for fetching remote embeddings.
	RemoteEmbeddingTimeoutMs *int `json:"remote_embedding_timeout_ms,omitempty"`

	// RerankHybridMatches When true, computes both text match and vector distance scores for all matches in hybrid search. Documents found only through keyword search will get a vector distance score, and documents found only through vector search will get a text match score.
	RerankHybridMatches *bool `json:"rerank_hybrid_matches,omitempty"`

	// SearchCutoffMs Typesense will attempt to return results early if the cutoff time has elapsed. This is not a strict guarantee and facet computation is not bound by this parameter.
	SearchCutoffMs *int `json:"search_cutoff_ms,omitempty"`

	// SnippetThreshold Field values under this length will be fully highlighted, instead of showing a snippet of relevant portion. Default: 30
	SnippetThreshold *int `json:"snippet_threshold,omitempty"`

	// SortBy A list of numerical fields and their corresponding sort orders that will be used for ordering your results. Up to 3 sort fields can be specified. The text similarity score is exposed as a special `_text_match` field that you can use in the list of sorting fields. If no `sort_by` parameter is specified, results are sorted by `_text_match:desc,default_sorting_field:desc`
	SortBy *string `json:"sort_by,omitempty"`

	// Stopwords Name of the stopwords set to apply for this search, the keywords present in the set will be removed from the search query.
	Stopwords *string `json:"stopwords,omitempty"`

	// SynonymNumTypos Allow synonym resolution on typo-corrected words in the query. Default: 0
	SynonymNumTypos *int `json:"synonym_num_typos,omitempty"`

	// SynonymPrefix Allow synonym resolution on word prefixes in the query. Default: false
	SynonymPrefix *bool `json:"synonym_prefix,omitempty"`

	// TextMatchType In a multi-field matching context, this parameter determines how the representative text match score of a record is calculated. Possible values are max_score (default) or max_weight.
	TextMatchType *string `json:"text_match_type,omitempty"`

	// TypoTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to look for tokens with more typos until enough results are found. Default: 100
	TypoTokensThreshold *int `json:"typo_tokens_threshold,omitempty"`

	// UseCache Enable server side caching of search query results. By default, caching is disabled.
	UseCache *bool `json:"use_cache,omitempty"`

	// VectorQuery Vector query expression for fetching documents "closest" to a given query/document vector.
	VectorQuery *string `json:"vector_query,omitempty"`

	// VoiceQuery The base64 encoded audio file in 16 khz 16-bit WAV format.
	VoiceQuery *string `json:"voice_query,omitempty"`

	// XTypesenseApiKey A separate search API key for each search within a multi_search request
	XTypesenseApiKey *string `json:"x-typesense-api-key,omitempty"`
}

// MultiSearchParameters Parameters for the multi search API.
type MultiSearchParameters struct {
	// CacheTtl The duration (in seconds) that determines how long the search query is cached. This value can be set on a per-query basis. Default: 60.
	CacheTtl *int `json:"cache_ttl,omitempty"`

	// Conversation Enable conversational search.
	Conversation *bool `json:"conversation,omitempty"`

	// ConversationId The Id of a previous conversation to continue, this tells Typesense to include prior context when communicating with the LLM.
	ConversationId *string `json:"conversation_id,omitempty"`

	// ConversationModelId The Id of Conversation Model to be used.
	ConversationModelId *string `json:"conversation_model_id,omitempty"`

	// DropTokensMode Dictates the direction in which the words in the query must be dropped when the original words in the query do not appear in any document. Values: right_to_left (default), left_to_right, both_sides:3 A note on both_sides:3 - for queries upto 3 tokens (words) in length, this mode will drop tokens from both sides and exhaustively rank all matching results. If query length is greater than 3 words, Typesense will just fallback to default behavior of right_to_left
	DropTokensMode *DropTokensMode `json:"drop_tokens_mode,omitempty"`

	// DropTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to drop the tokens in the query until enough results are found. Tokens that have the least individual hits are dropped first. Set to 0 to disable. Default: 10
	DropTokensThreshold *int `json:"drop_tokens_threshold,omitempty"`

	// EnableOverrides If you have some overrides defined but want to disable all of them during query time, you can do that by setting this parameter to false
	EnableOverrides *bool `json:"enable_overrides,omitempty"`

	// EnableSynonyms If you have some synonyms defined but want to disable all of them for a particular search query, set enable_synonyms to false. Default: true
	EnableSynonyms *bool `json:"enable_synonyms,omitempty"`

	// EnableTyposForAlphaNumericalTokens Set this parameter to false to disable typos on alphanumerical query tokens. Default: true.
	EnableTyposForAlphaNumericalTokens *bool `json:"enable_typos_for_alpha_numerical_tokens,omitempty"`

	// EnableTyposForNumericalTokens Make Typesense disable typos for numerical tokens.
	EnableTyposForNumericalTokens *bool `json:"enable_typos_for_numerical_tokens,omitempty"`

	// ExcludeFields List of fields from the document to exclude in the search result
	ExcludeFields *string `json:"exclude_fields,omitempty"`

	// ExhaustiveSearch Setting this to true will make Typesense consider all prefixes and typo corrections of the words in the query without stopping early when enough results are found (drop_tokens_threshold and typo_tokens_threshold configurations are ignored).
	ExhaustiveSearch *bool `json:"exhaustive_search,omitempty"`

	// FacetBy A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.
	FacetBy *string `json:"facet_by,omitempty"`

	// FacetQuery Facet values that are returned can now be filtered via this parameter. The matching facet text is also highlighted. For example, when faceting by `category`, you can set `facet_query=category:shoe` to return only facet values that contain the prefix "shoe".
	FacetQuery *string `json:"facet_query,omitempty"`

	// FacetReturnParent Comma separated string of nested facet fields whose parent object should be returned in facet response.
	FacetReturnParent *string `json:"facet_return_parent,omitempty"`

	// FacetStrategy Choose the underlying faceting strategy used. Comma separated string of allows values: exhaustive, top_values or automatic (default).
	FacetStrategy *string `json:"facet_strategy,omitempty"`

	// FilterBy Filter conditions for refining youropen api validator search results. Separate multiple conditions with &&.
	FilterBy *string `json:"filter_by,omitempty"`

	// FilterCuratedHits Whether the filter_by condition of the search query should be applicable to curated results (override definitions, pinned hits, hidden hits, etc.). Default: false
	FilterCuratedHits *bool `json:"filter_curated_hits,omitempty"`

	// GroupBy You can aggregate search results into groups or buckets by specify one or more `group_by` fields. Separate multiple fields with a comma. To group on a particular field, it must be a faceted field.
	GroupBy *string `json:"group_by,omitempty"`

	// GroupLimit Maximum number of hits to be returned for every group. If the `group_limit` is set as `K` then only the top K hits in each group are returned in the response. Default: 3
	GroupLimit *int `json:"group_limit,omitempty"`

	// GroupMissingValues Setting this parameter to true will place all documents that have a null value in the group_by field, into a single group. Setting this parameter to false, will cause each document with a null value in the group_by field to not be grouped with other documents. Default: true
	GroupMissingValues *bool `json:"group_missing_values,omitempty"`

	// HiddenHits A list of records to unconditionally hide from search results. A list of `record_id`s to hide. Eg: to hide records with IDs 123 and 456, you'd specify `123,456`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	HiddenHits *string `json:"hidden_hits,omitempty"`

	// HighlightAffixNumTokens The number of tokens that should surround the highlighted text on each side. Default: 4
	HighlightAffixNumTokens *int `json:"highlight_affix_num_tokens,omitempty"`

	// HighlightEndTag The end tag used for the highlighted snippets. Default: `</mark>`
	HighlightEndTag *string `json:"highlight_end_tag,omitempty"`

	// HighlightFields A list of custom fields that must be highlighted even if you don't query for them
	HighlightFields *string `json:"highlight_fields,omitempty"`

	// HighlightFullFields List of fields which should be highlighted fully without snippeting
	HighlightFullFields *string `json:"highlight_full_fields,omitempty"`

	// HighlightStartTag The start tag used for the highlighted snippets. Default: `<mark>`
	HighlightStartTag *string `json:"highlight_start_tag,omitempty"`

	// IncludeFields List of fields from the document to include in the search result
	IncludeFields *string `json:"include_fields,omitempty"`

	// Infix If infix index is enabled for this field, infix searching can be done on a per-field basis by sending a comma separated string parameter called infix to the search query. This parameter can have 3 values; `off` infix search is disabled, which is default `always` infix search is performed along with regular search `fallback` infix search is performed if regular search does not produce results
	Infix *string `json:"infix,omitempty"`

	// Limit Number of hits to fetch. Can be used as an alternative to the per_page parameter. Default: 10.
	Limit *int `json:"limit,omitempty"`

	// MaxExtraPrefix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraPrefix *int `json:"max_extra_prefix,omitempty"`

	// MaxExtraSuffix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraSuffix *int `json:"max_extra_suffix,omitempty"`

	// MaxFacetValues Maximum number of facet values to be returned.
	MaxFacetValues *int `json:"max_facet_values,omitempty"`

	// MinLen1typo Minimum word length for 1-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen1typo *int `json:"min_len_1typo,omitempty"`

	// MinLen2typo Minimum word length for 2-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen2typo *int `json:"min_len_2typo,omitempty"`

	// NumTypos The number of typographical errors (1 or 2) that would be tolerated. Default: 2
	NumTypos *string `json:"num_typos,omitempty"`

	// Offset Identifies the starting point to return hits from a result set. Can be used as an alternative to the page parameter.
	Offset *int `json:"offset,omitempty"`

	// OverrideTags Comma separated list of tags to trigger the curations rules that match the tags.
	OverrideTags *string `json:"override_tags,omitempty"`

	// Page Results from this specific page number would be fetched.
	Page *int `json:"page,omitempty"`

	// PerPage Number of results to fetch per page. Default: 10
	PerPage *int `json:"per_page,omitempty"`

	// PinnedHits A list of records to unconditionally include in the search results at specific positions. An example use case would be to feature or promote certain items on the top of search results. A list of `record_id:hit_position`. Eg: to include a record with ID 123 at Position 1 and another record with ID 456 at Position 5, you'd specify `123:1,456:5`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	PinnedHits *string `json:"pinned_hits,omitempty"`

	// PreSegmentedQuery You can index content from any logographic language into Typesense if you are able to segment / split the text into space-separated words yourself before indexing and querying.
	// Set this parameter to true to do the same
	PreSegmentedQuery *bool `json:"pre_segmented_query,omitempty"`

	// Prefix Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole word. This is used for building autocomplete and instant search interfaces. Defaults to true.
	Prefix *string `json:"prefix,omitempty"`

	// Preset Search using a bunch of search parameters by setting this parameter to the name of the existing Preset.
	Preset *string `json:"preset,omitempty"`

	// PrioritizeExactMatch Set this parameter to true to ensure that an exact match is ranked above the others
	PrioritizeExactMatch *bool `json:"prioritize_exact_match,omitempty"`

	// PrioritizeNumMatchingFields Make Typesense prioritize documents where the query words appear in more number of fields.
	PrioritizeNumMatchingFields *bool `json:"prioritize_num_matching_fields,omitempty"`

	// PrioritizeTokenPosition Make Typesense prioritize documents where the query words appear earlier in the text.
	PrioritizeTokenPosition *bool `json:"prioritize_token_position,omitempty"`

	// Q The query text to search for in the collection. Use * as the search string to return all documents. This is typically useful when used in conjunction with filter_by.
	Q *string `json:"q,omitempty"`

	// QueryBy A list of `string` fields that should be queried against. Multiple fields are separated with a comma.
	QueryBy *string `json:"query_by,omitempty"`

	// QueryByWeights The relative weight to give each `query_by` field when ranking results. This can be used to boost fields in priority, when looking for matches. Multiple fields are separated with a comma.
	QueryByWeights *string `json:"query_by_weights,omitempty"`

	// RemoteEmbeddingNumTries Number of times to retry fetching remote embeddings.
	RemoteEmbeddingNumTries *int `json:"remote_embedding_num_tries,omitempty"`

	// RemoteEmbeddingTimeoutMs Timeout (in milliseconds) for fetching remote embeddings.
	RemoteEmbeddingTimeoutMs *int `json:"remote_embedding_timeout_ms,omitempty"`

	// SearchCutoffMs Typesense will attempt to return results early if the cutoff time has elapsed. This is not a strict guarantee and facet computation is not bound by this parameter.
	SearchCutoffMs *int `json:"search_cutoff_ms,omitempty"`

	// SnippetThreshold Field values under this length will be fully highlighted, instead of showing a snippet of relevant portion. Default: 30
	SnippetThreshold *int `json:"snippet_threshold,omitempty"`

	// SortBy A list of numerical fields and their corresponding sort orders that will be used for ordering your results. Up to 3 sort fields can be specified. The text similarity score is exposed as a special `_text_match` field that you can use in the list of sorting fields. If no `sort_by` parameter is specified, results are sorted by `_text_match:desc,default_sorting_field:desc`
	SortBy *string `json:"sort_by,omitempty"`

	// Stopwords Name of the stopwords set to apply for this search, the keywords present in the set will be removed from the search query.
	Stopwords *string `json:"stopwords,omitempty"`

	// SynonymNumTypos Allow synonym resolution on typo-corrected words in the query. Default: 0
	SynonymNumTypos *int `json:"synonym_num_typos,omitempty"`

	// SynonymPrefix Allow synonym resolution on word prefixes in the query. Default: false
	SynonymPrefix *bool `json:"synonym_prefix,omitempty"`

	// TextMatchType In a multi-field matching context, this parameter determines how the representative text match score of a record is calculated. Possible values are max_score (default) or max_weight.
	TextMatchType *string `json:"text_match_type,omitempty"`

	// TypoTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to look for tokens with more typos until enough results are found. Default: 100
	TypoTokensThreshold *int `json:"typo_tokens_threshold,omitempty"`

	// UseCache Enable server side caching of search query results. By default, caching is disabled.
	UseCache *bool `json:"use_cache,omitempty"`

	// VectorQuery Vector query expression for fetching documents "closest" to a given query/document vector.
	VectorQuery *string `json:"vector_query,omitempty"`

	// VoiceQuery The base64 encoded audio file in 16 khz 16-bit WAV format.
	VoiceQuery *string `json:"voice_query,omitempty"`
}

// MultiSearchResult defines model for MultiSearchResult.
type MultiSearchResult struct {
	Conversation *SearchResultConversation `json:"conversation,omitempty"`
	Results      []MultiSearchResultItem   `json:"results"`
}

// MultiSearchResultItem defines model for MultiSearchResultItem.
type MultiSearchResultItem struct {
	// Code HTTP error code
	Code         *int64                    `json:"code,omitempty"`
	Conversation *SearchResultConversation `json:"conversation,omitempty"`

	// Error Error description
	Error       *string        `json:"error,omitempty"`
	FacetCounts *[]FacetCounts `json:"facet_counts,omitempty"`

	// Found The number of documents found
	Found       *int                `json:"found,omitempty"`
	FoundDocs   *int                `json:"found_docs,omitempty"`
	GroupedHits *[]SearchGroupedHit `json:"grouped_hits,omitempty"`

	// Hits The documents that matched the search query
	Hits *[]SearchResultHit `json:"hits,omitempty"`

	// OutOf The total number of documents in the collection
	OutOf *int `json:"out_of,omitempty"`

	// Page The search result page number
	Page          *int                 `json:"page,omitempty"`
	RequestParams *SearchRequestParams `json:"request_params,omitempty"`

	// SearchCutoff Whether the search was cut off
	SearchCutoff *bool `json:"search_cutoff,omitempty"`

	// SearchTimeMs The number of milliseconds the search took
	SearchTimeMs *int `json:"search_time_ms,omitempty"`

	// UnionRequestParams Returned only for union query response.
	UnionRequestParams *[]SearchRequestParams `json:"union_request_params,omitempty"`
}

// MultiSearchSearchesParameter defines model for MultiSearchSearchesParameter.
type MultiSearchSearchesParameter struct {
	Searches []MultiSearchCollectionParameters `json:"searches"`

	// Union When true, merges the search results from each search query into a single ordered set of hits.
	Union *bool `json:"union,omitempty"`
}

// NLSearchModelBase defines model for NLSearchModelBase.
type NLSearchModelBase struct {
	// AccessToken Access token for GCP Vertex AI
	AccessToken *string `json:"access_token,omitempty"`

	// AccountId Account ID for Cloudflare-specific models
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey API key for the NL model service
	ApiKey *string `json:"api_key,omitempty"`

	// ApiUrl Custom API URL for the NL model service
	ApiUrl *string `json:"api_url,omitempty"`

	// ApiVersion API version for the NL model service
	ApiVersion *string `json:"api_version,omitempty"`

	// ClientId Client ID for GCP Vertex AI
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for GCP Vertex AI
	ClientSecret *string `json:"client_secret,omitempty"`

	// MaxBytes Maximum number of bytes to process
	MaxBytes *int `json:"max_bytes,omitempty"`

	// MaxOutputTokens Maximum output tokens for GCP Vertex AI
	MaxOutputTokens *int `json:"max_output_tokens,omitempty"`

	// ModelName Name of the NL model to use
	ModelName *string `json:"model_name,omitempty"`

	// ProjectId Project ID for GCP Vertex AI
	ProjectId *string `json:"project_id,omitempty"`

	// RefreshToken Refresh token for GCP Vertex AI
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Region Region for GCP Vertex AI
	Region *string `json:"region,omitempty"`

	// StopSequences Stop sequences for the NL model (Google-specific)
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// SystemPrompt System prompt for the NL model
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Temperature Temperature parameter for the NL model
	Temperature *float32 `json:"temperature,omitempty"`

	// TopK Top-k parameter for the NL model (Google-specific)
	TopK *int `json:"top_k,omitempty"`

	// TopP Top-p parameter for the NL model (Google-specific)
	TopP *float32 `json:"top_p,omitempty"`
}

// NLSearchModelCreateSchema defines model for NLSearchModelCreateSchema.
type NLSearchModelCreateSchema struct {
	// AccessToken Access token for GCP Vertex AI
	AccessToken *string `json:"access_token,omitempty"`

	// AccountId Account ID for Cloudflare-specific models
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey API key for the NL model service
	ApiKey *string `json:"api_key,omitempty"`

	// ApiUrl Custom API URL for the NL model service
	ApiUrl *string `json:"api_url,omitempty"`

	// ApiVersion API version for the NL model service
	ApiVersion *string `json:"api_version,omitempty"`

	// ClientId Client ID for GCP Vertex AI
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for GCP Vertex AI
	ClientSecret *string `json:"client_secret,omitempty"`

	// Id Optional ID for the NL search model
	Id *string `json:"id,omitempty"`

	// MaxBytes Maximum number of bytes to process
	MaxBytes *int `json:"max_bytes,omitempty"`

	// MaxOutputTokens Maximum output tokens for GCP Vertex AI
	MaxOutputTokens *int `json:"max_output_tokens,omitempty"`

	// ModelName Name of the NL model to use
	ModelName *string `json:"model_name,omitempty"`

	// ProjectId Project ID for GCP Vertex AI
	ProjectId *string `json:"project_id,omitempty"`

	// RefreshToken Refresh token for GCP Vertex AI
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Region Region for GCP Vertex AI
	Region *string `json:"region,omitempty"`

	// StopSequences Stop sequences for the NL model (Google-specific)
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// SystemPrompt System prompt for the NL model
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Temperature Temperature parameter for the NL model
	Temperature *float32 `json:"temperature,omitempty"`

	// TopK Top-k parameter for the NL model (Google-specific)
	TopK *int `json:"top_k,omitempty"`

	// TopP Top-p parameter for the NL model (Google-specific)
	TopP *float32 `json:"top_p,omitempty"`
}

// NLSearchModelDeleteSchema defines model for NLSearchModelDeleteSchema.
type NLSearchModelDeleteSchema struct {
	// Id ID of the deleted NL search model
	Id string `json:"id"`
}

// NLSearchModelSchema defines model for NLSearchModelSchema.
type NLSearchModelSchema struct {
	// AccessToken Access token for GCP Vertex AI
	AccessToken *string `json:"access_token,omitempty"`

	// AccountId Account ID for Cloudflare-specific models
	AccountId *string `json:"account_id,omitempty"`

	// ApiKey API key for the NL model service
	ApiKey *string `json:"api_key,omitempty"`

	// ApiUrl Custom API URL for the NL model service
	ApiUrl *string `json:"api_url,omitempty"`

	// ApiVersion API version for the NL model service
	ApiVersion *string `json:"api_version,omitempty"`

	// ClientId Client ID for GCP Vertex AI
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Client secret for GCP Vertex AI
	ClientSecret *string `json:"client_secret,omitempty"`

	// Id ID of the NL search model
	Id string `json:"id"`

	// MaxBytes Maximum number of bytes to process
	MaxBytes *int `json:"max_bytes,omitempty"`

	// MaxOutputTokens Maximum output tokens for GCP Vertex AI
	MaxOutputTokens *int `json:"max_output_tokens,omitempty"`

	// ModelName Name of the NL model to use
	ModelName *string `json:"model_name,omitempty"`

	// ProjectId Project ID for GCP Vertex AI
	ProjectId *string `json:"project_id,omitempty"`

	// RefreshToken Refresh token for GCP Vertex AI
	RefreshToken *string `json:"refresh_token,omitempty"`

	// Region Region for GCP Vertex AI
	Region *string `json:"region,omitempty"`

	// StopSequences Stop sequences for the NL model (Google-specific)
	StopSequences *[]string `json:"stop_sequences,omitempty"`

	// SystemPrompt System prompt for the NL model
	SystemPrompt *string `json:"system_prompt,omitempty"`

	// Temperature Temperature parameter for the NL model
	Temperature *float32 `json:"temperature,omitempty"`

	// TopK Top-k parameter for the NL model (Google-specific)
	TopK *int `json:"top_k,omitempty"`

	// TopP Top-p parameter for the NL model (Google-specific)
	TopP *float32 `json:"top_p,omitempty"`
}

// NLSearchModelUpdateSchema defines model for NLSearchModelUpdateSchema.
type NLSearchModelUpdateSchema = NLSearchModelCreateSchema

// PresetDeleteSchema defines model for PresetDeleteSchema.
type PresetDeleteSchema struct {
	Name string `json:"name"`
}

// PresetSchema defines model for PresetSchema.
type PresetSchema struct {
	Name  string             `json:"name"`
	Value PresetSchema_Value `json:"value"`
}

// PresetSchema_Value defines model for PresetSchema.Value.
type PresetSchema_Value struct {
	union json.RawMessage
}

// PresetUpsertSchema defines model for PresetUpsertSchema.
type PresetUpsertSchema struct {
	Value PresetUpsertSchema_Value `json:"value"`
}

// PresetUpsertSchema_Value defines model for PresetUpsertSchema.Value.
type PresetUpsertSchema_Value struct {
	union json.RawMessage
}

// PresetsRetrieveSchema defines model for PresetsRetrieveSchema.
type PresetsRetrieveSchema struct {
	Presets []*PresetSchema `json:"presets"`
}

// SchemaChangeStatus defines model for SchemaChangeStatus.
type SchemaChangeStatus struct {
	// AlteredDocs Number of documents that have been altered
	AlteredDocs *int `json:"altered_docs,omitempty"`

	// Collection Name of the collection being modified
	Collection *string `json:"collection,omitempty"`

	// ValidatedDocs Number of documents that have been validated
	ValidatedDocs *int `json:"validated_docs,omitempty"`
}

// SearchGroupedHit defines model for SearchGroupedHit.
type SearchGroupedHit struct {
	Found    *int          `json:"found,omitempty"`
	GroupKey []interface{} `json:"group_key"`

	// Hits The documents that matched the search query
	Hits []SearchResultHit `json:"hits"`
}

// SearchHighlight defines model for SearchHighlight.
type SearchHighlight struct {
	Field *string `json:"field,omitempty"`

	// Indices The indices property will be present only for string[] fields and will contain the corresponding indices of the snippets in the search field
	Indices       *[]int         `json:"indices,omitempty"`
	MatchedTokens *[]interface{} `json:"matched_tokens,omitempty"`

	// Snippet Present only for (non-array) string fields
	Snippet *string `json:"snippet,omitempty"`

	// Snippets Present only for (array) string[] fields
	Snippets *[]string `json:"snippets,omitempty"`

	// Value Full field value with highlighting, present only for (non-array) string fields
	Value *string `json:"value,omitempty"`

	// Values Full field value with highlighting, present only for (array) string[] fields
	Values *[]string `json:"values,omitempty"`
}

// SearchOverride defines model for SearchOverride.
type SearchOverride struct {
	// EffectiveFromTs A Unix timestamp that indicates the date/time from which the override will be active. You can use this to create override rules that start applying from a future point in time.
	EffectiveFromTs *int `json:"effective_from_ts,omitempty"`

	// EffectiveToTs A Unix timestamp that indicates the date/time until which the override will be active. You can use this to create override rules that stop applying after a period of time.
	EffectiveToTs *int `json:"effective_to_ts,omitempty"`

	// Excludes List of document `id`s that should be excluded from the search results.
	Excludes *[]SearchOverrideExclude `json:"excludes,omitempty"`

	// FilterBy A filter by clause that is applied to any search query that matches the override rule.
	FilterBy *string `json:"filter_by,omitempty"`

	// FilterCuratedHits When set to true, the filter conditions of the query is applied to the curated records as well. Default: false.
	FilterCuratedHits *bool   `json:"filter_curated_hits,omitempty"`
	Id                *string `json:"id,omitempty"`

	// Includes List of document `id`s that should be included in the search results with their corresponding `position`s.
	Includes *[]SearchOverrideInclude `json:"includes,omitempty"`

	// Metadata Return a custom JSON object in the Search API response, when this rule is triggered. This can can be used to display a pre-defined message (eg: a promotion banner) on the front-end when a particular rule is triggered.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RemoveMatchedTokens Indicates whether search query tokens that exist in the override's rule should be removed from the search query.
	RemoveMatchedTokens *bool `json:"remove_matched_tokens,omitempty"`

	// ReplaceQuery Replaces the current search query with this value, when the search query matches the override rule.
	ReplaceQuery *string            `json:"replace_query,omitempty"`
	Rule         SearchOverrideRule `json:"rule"`

	// SortBy A sort by clause that is applied to any search query that matches the override rule.
	SortBy *string `json:"sort_by,omitempty"`

	// StopProcessing When set to true, override processing will stop at the first matching rule. When set to false override processing will continue and multiple override actions will be triggered in sequence. Overrides are processed in the lexical sort order of their id field. Default: true.
	StopProcessing *bool `json:"stop_processing,omitempty"`
}

// SearchOverrideDeleteResponse defines model for SearchOverrideDeleteResponse.
type SearchOverrideDeleteResponse struct {
	// Id The id of the override that was deleted
	Id string `json:"id"`
}

// SearchOverrideExclude defines model for SearchOverrideExclude.
type SearchOverrideExclude struct {
	// Id document id that should be excluded from the search results.
	Id string `json:"id"`
}

// SearchOverrideInclude defines model for SearchOverrideInclude.
type SearchOverrideInclude struct {
	// Id document id that should be included
	Id string `json:"id"`

	// Position position number where document should be included in the search results
	Position int `json:"position"`
}

// SearchOverrideRule defines model for SearchOverrideRule.
type SearchOverrideRule struct {
	// FilterBy Indicates that the override should apply when the filter_by parameter in a search query exactly matches the string specified here (including backticks, spaces, brackets, etc).
	FilterBy *string `json:"filter_by,omitempty"`

	// Match Indicates whether the match on the query term should be `exact` or `contains`. If we want to match all queries that contained the word `apple`, we will use the `contains` match instead.
	Match *SearchOverrideRuleMatch `json:"match,omitempty"`

	// Query Indicates what search queries should be overridden
	Query *string `json:"query,omitempty"`

	// Tags List of tag values to associate with this override rule.
	Tags *[]string `json:"tags,omitempty"`
}

// SearchOverrideRuleMatch Indicates whether the match on the query term should be `exact` or `contains`. If we want to match all queries that contained the word `apple`, we will use the `contains` match instead.
type SearchOverrideRuleMatch string

// SearchOverrideSchema defines model for SearchOverrideSchema.
type SearchOverrideSchema struct {
	// EffectiveFromTs A Unix timestamp that indicates the date/time from which the override will be active. You can use this to create override rules that start applying from a future point in time.
	EffectiveFromTs *int `json:"effective_from_ts,omitempty"`

	// EffectiveToTs A Unix timestamp that indicates the date/time until which the override will be active. You can use this to create override rules that stop applying after a period of time.
	EffectiveToTs *int `json:"effective_to_ts,omitempty"`

	// Excludes List of document `id`s that should be excluded from the search results.
	Excludes *[]SearchOverrideExclude `json:"excludes,omitempty"`

	// FilterBy A filter by clause that is applied to any search query that matches the override rule.
	FilterBy *string `json:"filter_by,omitempty"`

	// FilterCuratedHits When set to true, the filter conditions of the query is applied to the curated records as well. Default: false.
	FilterCuratedHits *bool `json:"filter_curated_hits,omitempty"`

	// Includes List of document `id`s that should be included in the search results with their corresponding `position`s.
	Includes *[]SearchOverrideInclude `json:"includes,omitempty"`

	// Metadata Return a custom JSON object in the Search API response, when this rule is triggered. This can can be used to display a pre-defined message (eg: a promotion banner) on the front-end when a particular rule is triggered.
	Metadata *map[string]interface{} `json:"metadata,omitempty"`

	// RemoveMatchedTokens Indicates whether search query tokens that exist in the override's rule should be removed from the search query.
	RemoveMatchedTokens *bool `json:"remove_matched_tokens,omitempty"`

	// ReplaceQuery Replaces the current search query with this value, when the search query matches the override rule.
	ReplaceQuery *string            `json:"replace_query,omitempty"`
	Rule         SearchOverrideRule `json:"rule"`

	// SortBy A sort by clause that is applied to any search query that matches the override rule.
	SortBy *string `json:"sort_by,omitempty"`

	// StopProcessing When set to true, override processing will stop at the first matching rule. When set to false override processing will continue and multiple override actions will be triggered in sequence. Overrides are processed in the lexical sort order of their id field. Default: true.
	StopProcessing *bool `json:"stop_processing,omitempty"`
}

// SearchOverridesResponse defines model for SearchOverridesResponse.
type SearchOverridesResponse struct {
	Overrides []*SearchOverride `json:"overrides"`
}

// SearchParameters defines model for SearchParameters.
type SearchParameters struct {
	// CacheTtl The duration (in seconds) that determines how long the search query is cached. This value can be set on a per-query basis. Default: 60.
	CacheTtl *int `json:"cache_ttl,omitempty"`

	// Conversation Enable conversational search.
	Conversation *bool `json:"conversation,omitempty"`

	// ConversationId The Id of a previous conversation to continue, this tells Typesense to include prior context when communicating with the LLM.
	ConversationId *string `json:"conversation_id,omitempty"`

	// ConversationModelId The Id of Conversation Model to be used.
	ConversationModelId *string `json:"conversation_model_id,omitempty"`

	// DropTokensMode Dictates the direction in which the words in the query must be dropped when the original words in the query do not appear in any document. Values: right_to_left (default), left_to_right, both_sides:3 A note on both_sides:3 - for queries upto 3 tokens (words) in length, this mode will drop tokens from both sides and exhaustively rank all matching results. If query length is greater than 3 words, Typesense will just fallback to default behavior of right_to_left
	DropTokensMode *DropTokensMode `json:"drop_tokens_mode,omitempty"`

	// DropTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to drop the tokens in the query until enough results are found. Tokens that have the least individual hits are dropped first. Set to 0 to disable. Default: 10
	DropTokensThreshold *int `json:"drop_tokens_threshold,omitempty"`

	// EnableHighlightV1 Flag for enabling/disabling the deprecated, old highlight structure in the response. Default: true
	EnableHighlightV1 *bool `json:"enable_highlight_v1,omitempty"`

	// EnableOverrides If you have some overrides defined but want to disable all of them during query time, you can do that by setting this parameter to false
	EnableOverrides *bool `json:"enable_overrides,omitempty"`

	// EnableSynonyms If you have some synonyms defined but want to disable all of them for a particular search query, set enable_synonyms to false. Default: true
	EnableSynonyms *bool `json:"enable_synonyms,omitempty"`

	// EnableTyposForAlphaNumericalTokens Set this parameter to false to disable typos on alphanumerical query tokens. Default: true.
	EnableTyposForAlphaNumericalTokens *bool `json:"enable_typos_for_alpha_numerical_tokens,omitempty"`

	// EnableTyposForNumericalTokens Make Typesense disable typos for numerical tokens.
	EnableTyposForNumericalTokens *bool `json:"enable_typos_for_numerical_tokens,omitempty"`

	// ExcludeFields List of fields from the document to exclude in the search result
	ExcludeFields *string `json:"exclude_fields,omitempty"`

	// ExhaustiveSearch Setting this to true will make Typesense consider all prefixes and typo corrections of the words in the query without stopping early when enough results are found (drop_tokens_threshold and typo_tokens_threshold configurations are ignored).
	ExhaustiveSearch *bool `json:"exhaustive_search,omitempty"`

	// FacetBy A list of fields that will be used for faceting your results on. Separate multiple fields with a comma.
	FacetBy *string `json:"facet_by,omitempty"`

	// FacetQuery Facet values that are returned can now be filtered via this parameter. The matching facet text is also highlighted. For example, when faceting by `category`, you can set `facet_query=category:shoe` to return only facet values that contain the prefix "shoe".
	FacetQuery *string `json:"facet_query,omitempty"`

	// FacetReturnParent Comma separated string of nested facet fields whose parent object should be returned in facet response.
	FacetReturnParent *string `json:"facet_return_parent,omitempty"`

	// FacetStrategy Choose the underlying faceting strategy used. Comma separated string of allows values: exhaustive, top_values or automatic (default).
	FacetStrategy *string `json:"facet_strategy,omitempty"`

	// FilterBy Filter conditions for refining youropen api validator search results. Separate multiple conditions with &&.
	FilterBy *string `json:"filter_by,omitempty"`

	// FilterCuratedHits Whether the filter_by condition of the search query should be applicable to curated results (override definitions, pinned hits, hidden hits, etc.). Default: false
	FilterCuratedHits *bool `json:"filter_curated_hits,omitempty"`

	// GroupBy You can aggregate search results into groups or buckets by specify one or more `group_by` fields. Separate multiple fields with a comma. To group on a particular field, it must be a faceted field.
	GroupBy *string `json:"group_by,omitempty"`

	// GroupLimit Maximum number of hits to be returned for every group. If the `group_limit` is set as `K` then only the top K hits in each group are returned in the response. Default: 3
	GroupLimit *int `json:"group_limit,omitempty"`

	// GroupMissingValues Setting this parameter to true will place all documents that have a null value in the group_by field, into a single group. Setting this parameter to false, will cause each document with a null value in the group_by field to not be grouped with other documents. Default: true
	GroupMissingValues *bool `json:"group_missing_values,omitempty"`

	// HiddenHits A list of records to unconditionally hide from search results. A list of `record_id`s to hide. Eg: to hide records with IDs 123 and 456, you'd specify `123,456`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	HiddenHits *string `json:"hidden_hits,omitempty"`

	// HighlightAffixNumTokens The number of tokens that should surround the highlighted text on each side. Default: 4
	HighlightAffixNumTokens *int `json:"highlight_affix_num_tokens,omitempty"`

	// HighlightEndTag The end tag used for the highlighted snippets. Default: `</mark>`
	HighlightEndTag *string `json:"highlight_end_tag,omitempty"`

	// HighlightFields A list of custom fields that must be highlighted even if you don't query for them
	HighlightFields *string `json:"highlight_fields,omitempty"`

	// HighlightFullFields List of fields which should be highlighted fully without snippeting
	HighlightFullFields *string `json:"highlight_full_fields,omitempty"`

	// HighlightStartTag The start tag used for the highlighted snippets. Default: `<mark>`
	HighlightStartTag *string `json:"highlight_start_tag,omitempty"`

	// IncludeFields List of fields from the document to include in the search result
	IncludeFields *string `json:"include_fields,omitempty"`

	// Infix If infix index is enabled for this field, infix searching can be done on a per-field basis by sending a comma separated string parameter called infix to the search query. This parameter can have 3 values; `off` infix search is disabled, which is default `always` infix search is performed along with regular search `fallback` infix search is performed if regular search does not produce results
	Infix *string `json:"infix,omitempty"`

	// Limit Number of hits to fetch. Can be used as an alternative to the per_page parameter. Default: 10.
	Limit *int `json:"limit,omitempty"`

	// MaxCandidates Control the number of words that Typesense considers for typo and prefix searching.
	MaxCandidates *int `json:"max_candidates,omitempty"`

	// MaxExtraPrefix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraPrefix *int `json:"max_extra_prefix,omitempty"`

	// MaxExtraSuffix There are also 2 parameters that allow you to control the extent of infix searching max_extra_prefix and max_extra_suffix which specify the maximum number of symbols before or after the query that can be present in the token. For example query "K2100" has 2 extra symbols in "6PK2100". By default, any number of prefixes/suffixes can be present for a match.
	MaxExtraSuffix *int `json:"max_extra_suffix,omitempty"`

	// MaxFacetValues Maximum number of facet values to be returned.
	MaxFacetValues *int `json:"max_facet_values,omitempty"`

	// MaxFilterByCandidates Controls the number of similar words that Typesense considers during fuzzy search on filter_by values. Useful for controlling prefix matches like company_name:Acm*.
	MaxFilterByCandidates *int `json:"max_filter_by_candidates,omitempty"`

	// MinLen1typo Minimum word length for 1-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen1typo *int `json:"min_len_1typo,omitempty"`

	// MinLen2typo Minimum word length for 2-typo correction to be applied. The value of num_typos is still treated as the maximum allowed typos.
	MinLen2typo *int `json:"min_len_2typo,omitempty"`

	// NlModelId The ID of the natural language model to use.
	NlModelId *string `json:"nl_model_id,omitempty"`

	// NlQuery Whether to use natural language processing to parse the query.
	NlQuery *bool `json:"nl_query,omitempty"`

	// NumTypos The number of typographical errors (1 or 2) that would be tolerated. Default: 2
	NumTypos *string `json:"num_typos,omitempty"`

	// Offset Identifies the starting point to return hits from a result set. Can be used as an alternative to the page parameter.
	Offset *int `json:"offset,omitempty"`

	// OverrideTags Comma separated list of tags to trigger the curations rules that match the tags.
	OverrideTags *string `json:"override_tags,omitempty"`

	// Page Results from this specific page number would be fetched.
	Page *int `json:"page,omitempty"`

	// PerPage Number of results to fetch per page. Default: 10
	PerPage *int `json:"per_page,omitempty"`

	// PinnedHits A list of records to unconditionally include in the search results at specific positions. An example use case would be to feature or promote certain items on the top of search results. A list of `record_id:hit_position`. Eg: to include a record with ID 123 at Position 1 and another record with ID 456 at Position 5, you'd specify `123:1,456:5`.
	// You could also use the Overrides feature to override search results based on rules. Overrides are applied first, followed by `pinned_hits` and finally `hidden_hits`.
	PinnedHits *string `json:"pinned_hits,omitempty"`

	// PreSegmentedQuery You can index content from any logographic language into Typesense if you are able to segment / split the text into space-separated words yourself before indexing and querying.
	// Set this parameter to true to do the same
	PreSegmentedQuery *bool `json:"pre_segmented_query,omitempty"`

	// Prefix Boolean field to indicate that the last word in the query should be treated as a prefix, and not as a whole word. This is used for building autocomplete and instant search interfaces. Defaults to true.
	Prefix *string `json:"prefix,omitempty"`

	// Preset Search using a bunch of search parameters by setting this parameter to the name of the existing Preset.
	Preset *string `json:"preset,omitempty"`

	// PrioritizeExactMatch Set this parameter to true to ensure that an exact match is ranked above the others
	PrioritizeExactMatch *bool `json:"prioritize_exact_match,omitempty"`

	// PrioritizeNumMatchingFields Make Typesense prioritize documents where the query words appear in more number of fields.
	PrioritizeNumMatchingFields *bool `json:"prioritize_num_matching_fields,omitempty"`

	// PrioritizeTokenPosition Make Typesense prioritize documents where the query words appear earlier in the text.
	PrioritizeTokenPosition *bool `json:"prioritize_token_position,omitempty"`

	// Q The query text to search for in the collection. Use * as the search string to return all documents. This is typically useful when used in conjunction with filter_by.
	Q *string `json:"q,omitempty"`

	// QueryBy A list of `string` fields that should be queried against. Multiple fields are separated with a comma.
	QueryBy *string `json:"query_by,omitempty"`

	// QueryByWeights The relative weight to give each `query_by` field when ranking results. This can be used to boost fields in priority, when looking for matches. Multiple fields are separated with a comma.
	QueryByWeights *string `json:"query_by_weights,omitempty"`

	// RemoteEmbeddingNumTries Number of times to retry fetching remote embeddings.
	RemoteEmbeddingNumTries *int `json:"remote_embedding_num_tries,omitempty"`

	// RemoteEmbeddingTimeoutMs Timeout (in milliseconds) for fetching remote embeddings.
	RemoteEmbeddingTimeoutMs *int `json:"remote_embedding_timeout_ms,omitempty"`

	// SearchCutoffMs Typesense will attempt to return results early if the cutoff time has elapsed. This is not a strict guarantee and facet computation is not bound by this parameter.
	SearchCutoffMs *int `json:"search_cutoff_ms,omitempty"`

	// SnippetThreshold Field values under this length will be fully highlighted, instead of showing a snippet of relevant portion. Default: 30
	SnippetThreshold *int `json:"snippet_threshold,omitempty"`

	// SortBy A list of numerical fields and their corresponding sort orders that will be used for ordering your results. Up to 3 sort fields can be specified. The text similarity score is exposed as a special `_text_match` field that you can use in the list of sorting fields. If no `sort_by` parameter is specified, results are sorted by `_text_match:desc,default_sorting_field:desc`
	SortBy *string `json:"sort_by,omitempty"`

	// SplitJoinTokens Treat space as typo: search for q=basket ball if q=basketball is not found or vice-versa. Splitting/joining of tokens will only be attempted if the original query produces no results. To always trigger this behavior, set value to `always``. To disable, set value to `off`. Default is `fallback`.
	SplitJoinTokens *string `json:"split_join_tokens,omitempty"`

	// Stopwords Name of the stopwords set to apply for this search, the keywords present in the set will be removed from the search query.
	Stopwords *string `json:"stopwords,omitempty"`

	// SynonymNumTypos Allow synonym resolution on typo-corrected words in the query. Default: 0
	SynonymNumTypos *int `json:"synonym_num_typos,omitempty"`

	// SynonymPrefix Allow synonym resolution on word prefixes in the query. Default: false
	SynonymPrefix *bool `json:"synonym_prefix,omitempty"`

	// TextMatchType In a multi-field matching context, this parameter determines how the representative text match score of a record is calculated. Possible values are max_score (default) or max_weight.
	TextMatchType *string `json:"text_match_type,omitempty"`

	// TypoTokensThreshold If the number of results found for a specific query is less than this number, Typesense will attempt to look for tokens with more typos until enough results are found. Default: 100
	TypoTokensThreshold *int `json:"typo_tokens_threshold,omitempty"`

	// UseCache Enable server side caching of search query results. By default, caching is disabled.
	UseCache *bool `json:"use_cache,omitempty"`

	// VectorQuery Vector query expression for fetching documents "closest" to a given query/document vector.
	VectorQuery *string `json:"vector_query,omitempty"`

	// VoiceQuery The base64 encoded audio file in 16 khz 16-bit WAV format.
	VoiceQuery *string `json:"voice_query,omitempty"`
}

// SearchRequestParams defines model for SearchRequestParams.
type SearchRequestParams struct {
	CollectionName string `json:"collection_name"`
	PerPage        int    `json:"per_page"`
	Q              string `json:"q"`
	VoiceQuery     *struct {
		TranscribedQuery *string `json:"transcribed_query,omitempty"`
	} `json:"voice_query,omitempty"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	Conversation *SearchResultConversation `json:"conversation,omitempty"`
	FacetCounts  *[]FacetCounts            `json:"facet_counts,omitempty"`

	// Found The number of documents found
	Found       *int                `json:"found,omitempty"`
	FoundDocs   *int                `json:"found_docs,omitempty"`
	GroupedHits *[]SearchGroupedHit `json:"grouped_hits,omitempty"`

	// Hits The documents that matched the search query
	Hits *[]SearchResultHit `json:"hits,omitempty"`

	// OutOf The total number of documents in the collection
	OutOf *int `json:"out_of,omitempty"`

	// Page The search result page number
	Page          *int                 `json:"page,omitempty"`
	RequestParams *SearchRequestParams `json:"request_params,omitempty"`

	// SearchCutoff Whether the search was cut off
	SearchCutoff *bool `json:"search_cutoff,omitempty"`

	// SearchTimeMs The number of milliseconds the search took
	SearchTimeMs *int `json:"search_time_ms,omitempty"`

	// UnionRequestParams Returned only for union query response.
	UnionRequestParams *[]SearchRequestParams `json:"union_request_params,omitempty"`
}

// SearchResultConversation defines model for SearchResultConversation.
type SearchResultConversation struct {
	Answer              string                   `json:"answer"`
	ConversationHistory []map[string]interface{} `json:"conversation_history"`
	ConversationId      string                   `json:"conversation_id"`
	Query               string                   `json:"query"`
}

// SearchResultHit defines model for SearchResultHit.
type SearchResultHit struct {
	// Document Can be any key-value pair
	Document *map[string]interface{} `json:"document,omitempty"`

	// GeoDistanceMeters Can be any key-value pair
	GeoDistanceMeters *map[string]int `json:"geo_distance_meters,omitempty"`

	// Highlight Highlighted version of the matching document
	Highlight *map[string]interface{} `json:"highlight,omitempty"`

	// Highlights (Deprecated) Contains highlighted portions of the search fields
	Highlights *[]SearchHighlight `json:"highlights,omitempty"`

	// HybridSearchInfo Information about hybrid search scoring
	HybridSearchInfo *struct {
		// RankFusionScore Combined score from rank fusion of text and vector search
		RankFusionScore *float32 `json:"rank_fusion_score,omitempty"`
	} `json:"hybrid_search_info,omitempty"`

	// SearchIndex Returned only for union query response. Indicates the index of the query which this document matched to.
	SearchIndex   *int   `json:"search_index,omitempty"`
	TextMatch     *int64 `json:"text_match,omitempty"`
	TextMatchInfo *struct {
		BestFieldScore   *string `json:"best_field_score,omitempty"`
		BestFieldWeight  *int    `json:"best_field_weight,omitempty"`
		FieldsMatched    *int    `json:"fields_matched,omitempty"`
		NumTokensDropped *uint64 `json:"num_tokens_dropped,omitempty"`
		Score            *string `json:"score,omitempty"`
		TokensMatched    *int    `json:"tokens_matched,omitempty"`
		TypoPrefixScore  *int    `json:"typo_prefix_score,omitempty"`
	} `json:"text_match_info,omitempty"`

	// VectorDistance Distance between the query vector and matching document's vector value
	VectorDistance *float32 `json:"vector_distance,omitempty"`
}

// SearchSynonym defines model for SearchSynonym.
type SearchSynonym struct {
	Id *string `json:"id,omitempty"`

	// Locale Locale for the synonym, leave blank to use the standard tokenizer.
	Locale *string `json:"locale,omitempty"`

	// Root For 1-way synonyms, indicates the root word that words in the `synonyms` parameter map to.
	Root *string `json:"root,omitempty"`

	// SymbolsToIndex By default, special characters are dropped from synonyms. Use this attribute to specify which special characters should be indexed as is.
	SymbolsToIndex *[]string `json:"symbols_to_index,omitempty"`

	// Synonyms Array of words that should be considered as synonyms.
	Synonyms []string `json:"synonyms"`
}

// SearchSynonymDeleteResponse defines model for SearchSynonymDeleteResponse.
type SearchSynonymDeleteResponse struct {
	// Id The id of the synonym that was deleted
	Id string `json:"id"`
}

// SearchSynonymSchema defines model for SearchSynonymSchema.
type SearchSynonymSchema struct {
	// Locale Locale for the synonym, leave blank to use the standard tokenizer.
	Locale *string `json:"locale,omitempty"`

	// Root For 1-way synonyms, indicates the root word that words in the `synonyms` parameter map to.
	Root *string `json:"root,omitempty"`

	// SymbolsToIndex By default, special characters are dropped from synonyms. Use this attribute to specify which special characters should be indexed as is.
	SymbolsToIndex *[]string `json:"symbols_to_index,omitempty"`

	// Synonyms Array of words that should be considered as synonyms.
	Synonyms []string `json:"synonyms"`
}

// SearchSynonymsResponse defines model for SearchSynonymsResponse.
type SearchSynonymsResponse struct {
	Synonyms []*SearchSynonym `json:"synonyms"`
}

// StemmingDictionary defines model for StemmingDictionary.
type StemmingDictionary struct {
	// Id Unique identifier for the dictionary
	Id string `json:"id"`

	// Words List of word mappings in the dictionary
	Words []struct {
		// Root The root form of the word
		Root string `json:"root"`

		// Word The word form to be stemmed
		Word string `json:"word"`
	} `json:"words"`
}

// StopwordsSetRetrieveSchema defines model for StopwordsSetRetrieveSchema.
type StopwordsSetRetrieveSchema struct {
	Stopwords StopwordsSetSchema `json:"stopwords"`
}

// StopwordsSetSchema defines model for StopwordsSetSchema.
type StopwordsSetSchema struct {
	Id        string   `json:"id"`
	Locale    *string  `json:"locale,omitempty"`
	Stopwords []string `json:"stopwords"`
}

// StopwordsSetUpsertSchema defines model for StopwordsSetUpsertSchema.
type StopwordsSetUpsertSchema struct {
	Locale    *string  `json:"locale,omitempty"`
	Stopwords []string `json:"stopwords"`
}

// StopwordsSetsRetrieveAllSchema defines model for StopwordsSetsRetrieveAllSchema.
type StopwordsSetsRetrieveAllSchema struct {
	Stopwords []StopwordsSetSchema `json:"stopwords"`
}

// SuccessStatus defines model for SuccessStatus.
type SuccessStatus struct {
	Success bool `json:"success"`
}

// VoiceQueryModelCollectionConfig Configuration for the voice query model
type VoiceQueryModelCollectionConfig struct {
	ModelName *string `json:"model_name,omitempty"`
}

// GetCollectionsParams defines parameters for GetCollections.
type GetCollectionsParams struct {
	ExcludeFields *string `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`
	Limit         *int    `form:"limit,omitempty" json:"limit,omitempty"`
	Offset        *int    `form:"offset,omitempty" json:"offset,omitempty"`
}

// DeleteDocumentsParams defines parameters for DeleteDocuments.
type DeleteDocumentsParams struct {
	BatchSize      *int    `form:"batch_size,omitempty" json:"batch_size,omitempty"`
	FilterBy       *string `form:"filter_by,omitempty" json:"filter_by,omitempty"`
	IgnoreNotFound *bool   `form:"ignore_not_found,omitempty" json:"ignore_not_found,omitempty"`
	Truncate       *bool   `form:"truncate,omitempty" json:"truncate,omitempty"`
}

// UpdateDocumentsJSONBody defines parameters for UpdateDocuments.
type UpdateDocumentsJSONBody = interface{}

// UpdateDocumentsParams defines parameters for UpdateDocuments.
type UpdateDocumentsParams struct {
	FilterBy *string `form:"filter_by,omitempty" json:"filter_by,omitempty"`
}

// IndexDocumentJSONBody defines parameters for IndexDocument.
type IndexDocumentJSONBody = interface{}

// IndexDocumentParams defines parameters for IndexDocument.
type IndexDocumentParams struct {
	// Action Additional action to perform
	Action *IndexAction `form:"action,omitempty" json:"action,omitempty"`

	// DirtyValues Dealing with Dirty Data
	DirtyValues *DirtyValues `form:"dirty_values,omitempty" json:"dirty_values,omitempty"`
}

// ExportDocumentsParams defines parameters for ExportDocuments.
type ExportDocumentsParams struct {
	ExcludeFields *string `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`
	FilterBy      *string `form:"filter_by,omitempty" json:"filter_by,omitempty"`
	IncludeFields *string `form:"include_fields,omitempty" json:"include_fields,omitempty"`
}

// ImportDocumentsParams defines parameters for ImportDocuments.
type ImportDocumentsParams struct {
	Action                   *IndexAction `form:"action,omitempty" json:"action,omitempty"`
	BatchSize                *int         `form:"batch_size,omitempty" json:"batch_size,omitempty"`
	DirtyValues              *DirtyValues `form:"dirty_values,omitempty" json:"dirty_values,omitempty"`
	RemoteEmbeddingBatchSize *int         `form:"remote_embedding_batch_size,omitempty" json:"remote_embedding_batch_size,omitempty"`
	ReturnDoc                *bool        `form:"return_doc,omitempty" json:"return_doc,omitempty"`
	ReturnId                 *bool        `form:"return_id,omitempty" json:"return_id,omitempty"`
}

// SearchCollectionParams defines parameters for SearchCollection.
type SearchCollectionParams struct {
	CacheTtl                           *int            `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`
	Conversation                       *bool           `form:"conversation,omitempty" json:"conversation,omitempty"`
	ConversationId                     *string         `form:"conversation_id,omitempty" json:"conversation_id,omitempty"`
	ConversationModelId                *string         `form:"conversation_model_id,omitempty" json:"conversation_model_id,omitempty"`
	DropTokensMode                     *DropTokensMode `form:"drop_tokens_mode,omitempty" json:"drop_tokens_mode,omitempty"`
	DropTokensThreshold                *int            `form:"drop_tokens_threshold,omitempty" json:"drop_tokens_threshold,omitempty"`
	EnableHighlightV1                  *bool           `form:"enable_highlight_v1,omitempty" json:"enable_highlight_v1,omitempty"`
	EnableOverrides                    *bool           `form:"enable_overrides,omitempty" json:"enable_overrides,omitempty"`
	EnableSynonyms                     *bool           `form:"enable_synonyms,omitempty" json:"enable_synonyms,omitempty"`
	EnableTyposForAlphaNumericalTokens *bool           `form:"enable_typos_for_alpha_numerical_tokens,omitempty" json:"enable_typos_for_alpha_numerical_tokens,omitempty"`
	EnableTyposForNumericalTokens      *bool           `form:"enable_typos_for_numerical_tokens,omitempty" json:"enable_typos_for_numerical_tokens,omitempty"`
	ExcludeFields                      *string         `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`
	ExhaustiveSearch                   *bool           `form:"exhaustive_search,omitempty" json:"exhaustive_search,omitempty"`
	FacetBy                            *string         `form:"facet_by,omitempty" json:"facet_by,omitempty"`
	FacetQuery                         *string         `form:"facet_query,omitempty" json:"facet_query,omitempty"`
	FacetReturnParent                  *string         `form:"facet_return_parent,omitempty" json:"facet_return_parent,omitempty"`
	FacetStrategy                      *string         `form:"facet_strategy,omitempty" json:"facet_strategy,omitempty"`
	FilterBy                           *string         `form:"filter_by,omitempty" json:"filter_by,omitempty"`
	FilterCuratedHits                  *bool           `form:"filter_curated_hits,omitempty" json:"filter_curated_hits,omitempty"`
	GroupBy                            *string         `form:"group_by,omitempty" json:"group_by,omitempty"`
	GroupLimit                         *int            `form:"group_limit,omitempty" json:"group_limit,omitempty"`
	GroupMissingValues                 *bool           `form:"group_missing_values,omitempty" json:"group_missing_values,omitempty"`
	HiddenHits                         *string         `form:"hidden_hits,omitempty" json:"hidden_hits,omitempty"`
	HighlightAffixNumTokens            *int            `form:"highlight_affix_num_tokens,omitempty" json:"highlight_affix_num_tokens,omitempty"`
	HighlightEndTag                    *string         `form:"highlight_end_tag,omitempty" json:"highlight_end_tag,omitempty"`
	HighlightFields                    *string         `form:"highlight_fields,omitempty" json:"highlight_fields,omitempty"`
	HighlightFullFields                *string         `form:"highlight_full_fields,omitempty" json:"highlight_full_fields,omitempty"`
	HighlightStartTag                  *string         `form:"highlight_start_tag,omitempty" json:"highlight_start_tag,omitempty"`
	IncludeFields                      *string         `form:"include_fields,omitempty" json:"include_fields,omitempty"`
	Infix                              *string         `form:"infix,omitempty" json:"infix,omitempty"`
	Limit                              *int            `form:"limit,omitempty" json:"limit,omitempty"`
	MaxCandidates                      *int            `form:"max_candidates,omitempty" json:"max_candidates,omitempty"`
	MaxExtraPrefix                     *int            `form:"max_extra_prefix,omitempty" json:"max_extra_prefix,omitempty"`
	MaxExtraSuffix                     *int            `form:"max_extra_suffix,omitempty" json:"max_extra_suffix,omitempty"`
	MaxFacetValues                     *int            `form:"max_facet_values,omitempty" json:"max_facet_values,omitempty"`
	MaxFilterByCandidates              *int            `form:"max_filter_by_candidates,omitempty" json:"max_filter_by_candidates,omitempty"`
	MinLen1typo                        *int            `form:"min_len_1typo,omitempty" json:"min_len_1typo,omitempty"`
	MinLen2typo                        *int            `form:"min_len_2typo,omitempty" json:"min_len_2typo,omitempty"`
	NlModelId                          *string         `form:"nl_model_id,omitempty" json:"nl_model_id,omitempty"`
	NlQuery                            *bool           `form:"nl_query,omitempty" json:"nl_query,omitempty"`
	NumTypos                           *string         `form:"num_typos,omitempty" json:"num_typos,omitempty"`
	Offset                             *int            `form:"offset,omitempty" json:"offset,omitempty"`
	OverrideTags                       *string         `form:"override_tags,omitempty" json:"override_tags,omitempty"`
	Page                               *int            `form:"page,omitempty" json:"page,omitempty"`
	PerPage                            *int            `form:"per_page,omitempty" json:"per_page,omitempty"`
	PinnedHits                         *string         `form:"pinned_hits,omitempty" json:"pinned_hits,omitempty"`
	PreSegmentedQuery                  *bool           `form:"pre_segmented_query,omitempty" json:"pre_segmented_query,omitempty"`
	Prefix                             *string         `form:"prefix,omitempty" json:"prefix,omitempty"`
	Preset                             *string         `form:"preset,omitempty" json:"preset,omitempty"`
	PrioritizeExactMatch               *bool           `form:"prioritize_exact_match,omitempty" json:"prioritize_exact_match,omitempty"`
	PrioritizeNumMatchingFields        *bool           `form:"prioritize_num_matching_fields,omitempty" json:"prioritize_num_matching_fields,omitempty"`
	PrioritizeTokenPosition            *bool           `form:"prioritize_token_position,omitempty" json:"prioritize_token_position,omitempty"`
	Q                                  *string         `form:"q,omitempty" json:"q,omitempty"`
	QueryBy                            *string         `form:"query_by,omitempty" json:"query_by,omitempty"`
	QueryByWeights                     *string         `form:"query_by_weights,omitempty" json:"query_by_weights,omitempty"`
	RemoteEmbeddingNumTries            *int            `form:"remote_embedding_num_tries,omitempty" json:"remote_embedding_num_tries,omitempty"`
	RemoteEmbeddingTimeoutMs           *int            `form:"remote_embedding_timeout_ms,omitempty" json:"remote_embedding_timeout_ms,omitempty"`
	SearchCutoffMs                     *int            `form:"search_cutoff_ms,omitempty" json:"search_cutoff_ms,omitempty"`
	SnippetThreshold                   *int            `form:"snippet_threshold,omitempty" json:"snippet_threshold,omitempty"`
	SortBy                             *string         `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	SplitJoinTokens                    *string         `form:"split_join_tokens,omitempty" json:"split_join_tokens,omitempty"`
	Stopwords                          *string         `form:"stopwords,omitempty" json:"stopwords,omitempty"`
	SynonymNumTypos                    *int            `form:"synonym_num_typos,omitempty" json:"synonym_num_typos,omitempty"`
	SynonymPrefix                      *bool           `form:"synonym_prefix,omitempty" json:"synonym_prefix,omitempty"`
	TextMatchType                      *string         `form:"text_match_type,omitempty" json:"text_match_type,omitempty"`
	TypoTokensThreshold                *int            `form:"typo_tokens_threshold,omitempty" json:"typo_tokens_threshold,omitempty"`
	UseCache                           *bool           `form:"use_cache,omitempty" json:"use_cache,omitempty"`
	VectorQuery                        *string         `form:"vector_query,omitempty" json:"vector_query,omitempty"`
	VoiceQuery                         *string         `form:"voice_query,omitempty" json:"voice_query,omitempty"`
}

// UpdateDocumentJSONBody defines parameters for UpdateDocument.
type UpdateDocumentJSONBody = interface{}

// UpdateDocumentParams defines parameters for UpdateDocument.
type UpdateDocumentParams struct {
	// DirtyValues Dealing with Dirty Data
	DirtyValues *DirtyValues `form:"dirty_values,omitempty" json:"dirty_values,omitempty"`
}

// MultiSearchParams defines parameters for MultiSearch.
type MultiSearchParams struct {
	CacheTtl                           *int            `form:"cache_ttl,omitempty" json:"cache_ttl,omitempty"`
	Conversation                       *bool           `form:"conversation,omitempty" json:"conversation,omitempty"`
	ConversationId                     *string         `form:"conversation_id,omitempty" json:"conversation_id,omitempty"`
	ConversationModelId                *string         `form:"conversation_model_id,omitempty" json:"conversation_model_id,omitempty"`
	DropTokensMode                     *DropTokensMode `form:"drop_tokens_mode,omitempty" json:"drop_tokens_mode,omitempty"`
	DropTokensThreshold                *int            `form:"drop_tokens_threshold,omitempty" json:"drop_tokens_threshold,omitempty"`
	EnableHighlightV1                  *bool           `form:"enable_highlight_v1,omitempty" json:"enable_highlight_v1,omitempty"`
	EnableOverrides                    *bool           `form:"enable_overrides,omitempty" json:"enable_overrides,omitempty"`
	EnableSynonyms                     *bool           `form:"enable_synonyms,omitempty" json:"enable_synonyms,omitempty"`
	EnableTyposForAlphaNumericalTokens *bool           `form:"enable_typos_for_alpha_numerical_tokens,omitempty" json:"enable_typos_for_alpha_numerical_tokens,omitempty"`
	EnableTyposForNumericalTokens      *bool           `form:"enable_typos_for_numerical_tokens,omitempty" json:"enable_typos_for_numerical_tokens,omitempty"`
	ExcludeFields                      *string         `form:"exclude_fields,omitempty" json:"exclude_fields,omitempty"`
	ExhaustiveSearch                   *bool           `form:"exhaustive_search,omitempty" json:"exhaustive_search,omitempty"`
	FacetBy                            *string         `form:"facet_by,omitempty" json:"facet_by,omitempty"`
	FacetQuery                         *string         `form:"facet_query,omitempty" json:"facet_query,omitempty"`
	FacetReturnParent                  *string         `form:"facet_return_parent,omitempty" json:"facet_return_parent,omitempty"`
	FacetStrategy                      *string         `form:"facet_strategy,omitempty" json:"facet_strategy,omitempty"`
	FilterBy                           *string         `form:"filter_by,omitempty" json:"filter_by,omitempty"`
	FilterCuratedHits                  *bool           `form:"filter_curated_hits,omitempty" json:"filter_curated_hits,omitempty"`
	GroupBy                            *string         `form:"group_by,omitempty" json:"group_by,omitempty"`
	GroupLimit                         *int            `form:"group_limit,omitempty" json:"group_limit,omitempty"`
	GroupMissingValues                 *bool           `form:"group_missing_values,omitempty" json:"group_missing_values,omitempty"`
	HiddenHits                         *string         `form:"hidden_hits,omitempty" json:"hidden_hits,omitempty"`
	HighlightAffixNumTokens            *int            `form:"highlight_affix_num_tokens,omitempty" json:"highlight_affix_num_tokens,omitempty"`
	HighlightEndTag                    *string         `form:"highlight_end_tag,omitempty" json:"highlight_end_tag,omitempty"`
	HighlightFields                    *string         `form:"highlight_fields,omitempty" json:"highlight_fields,omitempty"`
	HighlightFullFields                *string         `form:"highlight_full_fields,omitempty" json:"highlight_full_fields,omitempty"`
	HighlightStartTag                  *string         `form:"highlight_start_tag,omitempty" json:"highlight_start_tag,omitempty"`
	IncludeFields                      *string         `form:"include_fields,omitempty" json:"include_fields,omitempty"`
	Infix                              *string         `form:"infix,omitempty" json:"infix,omitempty"`
	Limit                              *int            `form:"limit,omitempty" json:"limit,omitempty"`
	MaxCandidates                      *int            `form:"max_candidates,omitempty" json:"max_candidates,omitempty"`
	MaxExtraPrefix                     *int            `form:"max_extra_prefix,omitempty" json:"max_extra_prefix,omitempty"`
	MaxExtraSuffix                     *int            `form:"max_extra_suffix,omitempty" json:"max_extra_suffix,omitempty"`
	MaxFacetValues                     *int            `form:"max_facet_values,omitempty" json:"max_facet_values,omitempty"`
	MaxFilterByCandidates              *int            `form:"max_filter_by_candidates,omitempty" json:"max_filter_by_candidates,omitempty"`
	MinLen1typo                        *int            `form:"min_len_1typo,omitempty" json:"min_len_1typo,omitempty"`
	MinLen2typo                        *int            `form:"min_len_2typo,omitempty" json:"min_len_2typo,omitempty"`
	NlModelId                          *string         `form:"nl_model_id,omitempty" json:"nl_model_id,omitempty"`
	NlQuery                            *bool           `form:"nl_query,omitempty" json:"nl_query,omitempty"`
	NumTypos                           *string         `form:"num_typos,omitempty" json:"num_typos,omitempty"`
	Offset                             *int            `form:"offset,omitempty" json:"offset,omitempty"`
	OverrideTags                       *string         `form:"override_tags,omitempty" json:"override_tags,omitempty"`
	Page                               *int            `form:"page,omitempty" json:"page,omitempty"`
	PerPage                            *int            `form:"per_page,omitempty" json:"per_page,omitempty"`
	PinnedHits                         *string         `form:"pinned_hits,omitempty" json:"pinned_hits,omitempty"`
	PreSegmentedQuery                  *bool           `form:"pre_segmented_query,omitempty" json:"pre_segmented_query,omitempty"`
	Prefix                             *string         `form:"prefix,omitempty" json:"prefix,omitempty"`
	Preset                             *string         `form:"preset,omitempty" json:"preset,omitempty"`
	PrioritizeExactMatch               *bool           `form:"prioritize_exact_match,omitempty" json:"prioritize_exact_match,omitempty"`
	PrioritizeNumMatchingFields        *bool           `form:"prioritize_num_matching_fields,omitempty" json:"prioritize_num_matching_fields,omitempty"`
	PrioritizeTokenPosition            *bool           `form:"prioritize_token_position,omitempty" json:"prioritize_token_position,omitempty"`
	Q                                  *string         `form:"q,omitempty" json:"q,omitempty"`
	QueryBy                            *string         `form:"query_by,omitempty" json:"query_by,omitempty"`
	QueryByWeights                     *string         `form:"query_by_weights,omitempty" json:"query_by_weights,omitempty"`
	RemoteEmbeddingNumTries            *int            `form:"remote_embedding_num_tries,omitempty" json:"remote_embedding_num_tries,omitempty"`
	RemoteEmbeddingTimeoutMs           *int            `form:"remote_embedding_timeout_ms,omitempty" json:"remote_embedding_timeout_ms,omitempty"`
	SearchCutoffMs                     *int            `form:"search_cutoff_ms,omitempty" json:"search_cutoff_ms,omitempty"`
	SnippetThreshold                   *int            `form:"snippet_threshold,omitempty" json:"snippet_threshold,omitempty"`
	SortBy                             *string         `form:"sort_by,omitempty" json:"sort_by,omitempty"`
	SplitJoinTokens                    *string         `form:"split_join_tokens,omitempty" json:"split_join_tokens,omitempty"`
	Stopwords                          *string         `form:"stopwords,omitempty" json:"stopwords,omitempty"`
	SynonymNumTypos                    *int            `form:"synonym_num_typos,omitempty" json:"synonym_num_typos,omitempty"`
	SynonymPrefix                      *bool           `form:"synonym_prefix,omitempty" json:"synonym_prefix,omitempty"`
	TextMatchType                      *string         `form:"text_match_type,omitempty" json:"text_match_type,omitempty"`
	TypoTokensThreshold                *int            `form:"typo_tokens_threshold,omitempty" json:"typo_tokens_threshold,omitempty"`
	UseCache                           *bool           `form:"use_cache,omitempty" json:"use_cache,omitempty"`
	VectorQuery                        *string         `form:"vector_query,omitempty" json:"vector_query,omitempty"`
	VoiceQuery                         *string         `form:"voice_query,omitempty" json:"voice_query,omitempty"`
}

// TakeSnapshotParams defines parameters for TakeSnapshot.
type TakeSnapshotParams struct {
	// SnapshotPath The directory on the server where the snapshot should be saved.
	SnapshotPath string `form:"snapshot_path" json:"snapshot_path"`
}

// ImportStemmingDictionaryJSONBody defines parameters for ImportStemmingDictionary.
type ImportStemmingDictionaryJSONBody = string

// ImportStemmingDictionaryParams defines parameters for ImportStemmingDictionary.
type ImportStemmingDictionaryParams struct {
	// Id The ID to assign to the dictionary
	Id string `form:"id" json:"id"`
}

// UpsertAliasJSONRequestBody defines body for UpsertAlias for application/json ContentType.
type UpsertAliasJSONRequestBody = CollectionAliasSchema

// CreateAnalyticsEventJSONRequestBody defines body for CreateAnalyticsEvent for application/json ContentType.
type CreateAnalyticsEventJSONRequestBody = AnalyticsEventCreateSchema

// CreateAnalyticsRuleJSONRequestBody defines body for CreateAnalyticsRule for application/json ContentType.
type CreateAnalyticsRuleJSONRequestBody = AnalyticsRuleSchema

// UpsertAnalyticsRuleJSONRequestBody defines body for UpsertAnalyticsRule for application/json ContentType.
type UpsertAnalyticsRuleJSONRequestBody = AnalyticsRuleUpsertSchema

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CollectionSchema

// UpdateCollectionJSONRequestBody defines body for UpdateCollection for application/json ContentType.
type UpdateCollectionJSONRequestBody = CollectionUpdateSchema

// UpdateDocumentsJSONRequestBody defines body for UpdateDocuments for application/json ContentType.
type UpdateDocumentsJSONRequestBody = UpdateDocumentsJSONBody

// IndexDocumentJSONRequestBody defines body for IndexDocument for application/json ContentType.
type IndexDocumentJSONRequestBody = IndexDocumentJSONBody

// UpdateDocumentJSONRequestBody defines body for UpdateDocument for application/json ContentType.
type UpdateDocumentJSONRequestBody = UpdateDocumentJSONBody

// UpsertSearchOverrideJSONRequestBody defines body for UpsertSearchOverride for application/json ContentType.
type UpsertSearchOverrideJSONRequestBody = SearchOverrideSchema

// UpsertSearchSynonymJSONRequestBody defines body for UpsertSearchSynonym for application/json ContentType.
type UpsertSearchSynonymJSONRequestBody = SearchSynonymSchema

// CreateConversationModelJSONRequestBody defines body for CreateConversationModel for application/json ContentType.
type CreateConversationModelJSONRequestBody = ConversationModelCreateSchema

// UpdateConversationModelJSONRequestBody defines body for UpdateConversationModel for application/json ContentType.
type UpdateConversationModelJSONRequestBody = ConversationModelUpdateSchema

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = ApiKeySchema

// MultiSearchJSONRequestBody defines body for MultiSearch for application/json ContentType.
type MultiSearchJSONRequestBody = MultiSearchSearchesParameter

// CreateNLSearchModelJSONRequestBody defines body for CreateNLSearchModel for application/json ContentType.
type CreateNLSearchModelJSONRequestBody = NLSearchModelCreateSchema

// UpdateNLSearchModelJSONRequestBody defines body for UpdateNLSearchModel for application/json ContentType.
type UpdateNLSearchModelJSONRequestBody = NLSearchModelUpdateSchema

// UpsertPresetJSONRequestBody defines body for UpsertPreset for application/json ContentType.
type UpsertPresetJSONRequestBody = PresetUpsertSchema

// ImportStemmingDictionaryJSONRequestBody defines body for ImportStemmingDictionary for application/json ContentType.
type ImportStemmingDictionaryJSONRequestBody = ImportStemmingDictionaryJSONBody

// UpsertStopwordsSetJSONRequestBody defines body for UpsertStopwordsSet for application/json ContentType.
type UpsertStopwordsSetJSONRequestBody = StopwordsSetUpsertSchema

// AsSearchParameters returns the union data inside the PresetSchema_Value as a SearchParameters
func (t PresetSchema_Value) AsSearchParameters() (SearchParameters, error) {
	var body SearchParameters
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchParameters overwrites any union data inside the PresetSchema_Value as the provided SearchParameters
func (t *PresetSchema_Value) FromSearchParameters(v SearchParameters) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchParameters performs a merge with any union data inside the PresetSchema_Value, using the provided SearchParameters
func (t *PresetSchema_Value) MergeSearchParameters(v SearchParameters) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiSearchSearchesParameter returns the union data inside the PresetSchema_Value as a MultiSearchSearchesParameter
func (t PresetSchema_Value) AsMultiSearchSearchesParameter() (MultiSearchSearchesParameter, error) {
	var body MultiSearchSearchesParameter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiSearchSearchesParameter overwrites any union data inside the PresetSchema_Value as the provided MultiSearchSearchesParameter
func (t *PresetSchema_Value) FromMultiSearchSearchesParameter(v MultiSearchSearchesParameter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiSearchSearchesParameter performs a merge with any union data inside the PresetSchema_Value, using the provided MultiSearchSearchesParameter
func (t *PresetSchema_Value) MergeMultiSearchSearchesParameter(v MultiSearchSearchesParameter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PresetSchema_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PresetSchema_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSearchParameters returns the union data inside the PresetUpsertSchema_Value as a SearchParameters
func (t PresetUpsertSchema_Value) AsSearchParameters() (SearchParameters, error) {
	var body SearchParameters
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchParameters overwrites any union data inside the PresetUpsertSchema_Value as the provided SearchParameters
func (t *PresetUpsertSchema_Value) FromSearchParameters(v SearchParameters) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchParameters performs a merge with any union data inside the PresetUpsertSchema_Value, using the provided SearchParameters
func (t *PresetUpsertSchema_Value) MergeSearchParameters(v SearchParameters) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMultiSearchSearchesParameter returns the union data inside the PresetUpsertSchema_Value as a MultiSearchSearchesParameter
func (t PresetUpsertSchema_Value) AsMultiSearchSearchesParameter() (MultiSearchSearchesParameter, error) {
	var body MultiSearchSearchesParameter
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMultiSearchSearchesParameter overwrites any union data inside the PresetUpsertSchema_Value as the provided MultiSearchSearchesParameter
func (t *PresetUpsertSchema_Value) FromMultiSearchSearchesParameter(v MultiSearchSearchesParameter) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMultiSearchSearchesParameter performs a merge with any union data inside the PresetUpsertSchema_Value, using the provided MultiSearchSearchesParameter
func (t *PresetUpsertSchema_Value) MergeMultiSearchSearchesParameter(v MultiSearchSearchesParameter) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PresetUpsertSchema_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PresetUpsertSchema_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
